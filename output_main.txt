C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\config.py:
import os

class Config:
    WTF_CSRF_ENABLED = True
    
    # Use Heroku's DATABASE_URL if available (production), fallback to SQLite for local development
    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL', "sqlite:///mydatabase.sqlite").replace('postgres://', 'postgresql://')

    SQLALCHEMY_TRACK_MODIFICATIONS = False

C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\templates\communites.html:
{% extends "base.html" %}

{% block additional_css %}
<link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='css/community.css') }}">
{% endblock %}

{% block scripts %} 
{% endblock %}

{% block title %}Z&H Homes - Communities{% endblock %}

{% block content %}
<div class="section-spacer"></div>

<div class="community-cards">
    <!-- Card 1 -->
    <div class="card">
        <div class="card-image">
            <img src="{{ url_for('static', filename='images/payette-county.jpg') }}" alt="Payette Idaho New Homes">
        </div>
        <div class="card-content">
            <h2>Piper Glen</h2>
            <a href="{{ url_for('main_routes.piperglen') }}" class="cta-link">View Project</a>
        </div>
    </div>
    <!-- Additional cards can be added here -->
</div>
{% endblock %}

C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\templates\estimate_submitted.html:
{% extends "base.html" %}

{% block additional_css %}
    <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='css/submission.css') }}">
{% endblock %}

{% block content %}
<div class="section-spacer"></div>
<div class="submission-success">
  <div class="alert alert-success" role="alert">
    <h4 class="alert-heading">Submission Successful!</h4>
    <p>Your estimate request has been submitted successfully. We will see you at the scheduled date.</p>
    <hr>
    <p class="mb-0">Thank you for choosing us. You will be redirected back shortly. You have 45 seconds to save the date to your calendar.</p>
    <p class="mt-3">Estimator: {{ estimator }}</p>
    <p class="mt-3">Location: <a href="https://www.google.com/maps/place/221+North+Plymouth+Ave,+New+Plymouth,+Idaho+83655" target="_blank">221 North Plymouth Ave, New Plymouth, Idaho 83655</a></p>
    <p class="mt-3">Date: {{ date }}</p>
    <p class="mt-3">Time: {{ time }}</p>  <!-- This will now display the formatted time -->
    <div class="small-spacer"></div>
    <p class="mt-3">Add to Calendar: 
        <a href="https://www.google.com/calendar/render?action=TEMPLATE&text=Appointment+with+{{ estimator }}&dates={{ date|replace('-', '') }}T{{ time|replace(':', '') }}00Z/{{ date|replace('-', '') }}T{{ (time|replace(':', '')|int + 100) }}00Z&details=Your+appointment+at+425+S+Whitley+Dr,+Fruitland,+ID+83619&location=425+S+Whitley+Dr,+Fruitland,+ID+83619" target="_blank" class="btn btn-calendar">Google Calendar</a>
        <a href="{{ url_for('main_routes.generate_ics', estimator=estimator, location='221 North Plymouth Ave, New Plymouth, ID 83655', date=date, time=time) }}" target="_blank" class="btn btn-calendar">iCalendar</a>
    </p>
    <div class="section-spacer"></div>
    <!-- This button can stay for manual redirection, in case automatic redirection doesn't work -->
    <a href="{{ url_for('main_routes.index') }}" class="btn btn-primary mt-3">Return Home</a>
  </div>
</div>
<script>
  // JavaScript for automatic redirection
  document.addEventListener('DOMContentLoaded', (event) => {
    setTimeout(function() {
      // Use the referrer if available, or fall back to the home page
      window.location.href = "{{ request.args.get('referrer', url_for('main_routes.index')) }}";
    }, 45000); // 45000 milliseconds = 45 seconds
  });
</script>
{% endblock %}


C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\modules\indexing.py:
from flask import Flask, render_template, url_for, request, redirect, Response
import xml.etree.ElementTree as ET
import os
import requests
from app import create_app

# Sitemap generation function (to be modified as per your requirements)
def generate_sitemap(app):
    app = create_app()  # Create an instance of the Flask app
    with app.app_context():
        # Extract routes from the application
        links = []
        for rule in app.url_map.iter_rules():
            # Filter out rules you can't navigate to in a browser
            # and rules that require parameters
            if "GET" in rule.methods and len(rule.arguments) == 0:
                url = url_for(rule.endpoint, _external=True)
                links.append(url)

        # Generate sitemap
        urlset = ET.Element("urlset", xmlns="http://www.sitemaps.org/schemas/sitemap/0.9")
        for link in links:
            u = ET.SubElement(urlset, "url")
            loc = ET.SubElement(u, "loc")
            loc.text = link

        tree = ET.ElementTree(urlset)
        sitemap_path = os.path.join(app.static_folder, 'sitemap.xml')
        tree.write(sitemap_path, encoding='utf-8', xml_declaration=True)

    # Submit to Bing
    submit_sitemap_to_bing('http://www.znhhomebuilders.com/static/sitemap.xml')

def submit_sitemap_to_bing(sitemap_url):
    api_key = 'f00ed402512c4d4b929fec116ad623d3'  # Store this in a secure place
    submit_url = f'https://www.bing.com/indexnow?url={sitemap_url}&key={api_key}'
    response = requests.get(submit_url)
    if response.status_code == 200:
        print("Sitemap successfully submitted to Bing")
    else:
        print("Error submitting sitemap to Bing:", response.text)

def check_and_submit_new_page(page):
    if page.is_public:  # Check if the page is not login restricted
        submit_sitemap_to_bing(page.url)

C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\.gitattributes:
# Auto detect text files and perform LF normalization
* text=auto


C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\routes\blog.py:
from flask import Blueprint, render_template, redirect, url_for, flash, request, session
from flask_login import login_user, logout_user
from flask_mail import Message
from flask import current_app as app
# Assuming the below modules are part of your application
from app import db, mail, bcrypt  # Adjust 'yourapp' to your actual app's name
from app.models import User, Role  # Adjust 'yourapp.models' to your actual models' location
from app.forms import RegistrationForm, LoginForm, EstimateRequestForm  # Adjust 'yourapp.forms' to your actual forms' location

blog_blueprint = Blueprint('blog', __name__, template_folder='templates/')
news_update = Blueprint('news', __name__, template_folder='templates/')
updates_blueprint = Blueprint('updates', __name__, template_folder='templates')

@blog_blueprint.context_processor
def combined_context_processor():
    locations = get_locations()
    erf_form = EstimateRequestForm()
    return dict(erf_form=erf_form, hide_estimate_form=True)

@news_update.context_processor
def combined_context_processor():
    locations = get_locations()
    erf_form = EstimateRequestForm()
    return dict(erf_form=erf_form, hide_estimate_form=True)

@updates_blueprint.context_processor
def combined_context_processor():
    locations = get_locations()
    erf_form = EstimateRequestForm()
    return dict(erf_form=erf_form, hide_estimate_form=True)

@blog_blueprint.route('/blog')
def show_blog():
    return render_template('blog.html')

@blog_blueprint.route('/blog/blog1.html')
def custom_built_home_timeline():
    return render_template('blog1.html')


C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\database.py:
from flask_sqlalchemy import SQLAlchemy

db = SQLAlchemy()


C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\templates\blog.html:
{% extends 'base.html' %}

{% block additional_css %}
    <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='css/blog.css') }}">
{% endblock %}

{% block title %}Blog Posts{% endblock %}

{% block content %}
<div class="blog-posts">
    <article class="post">
        <h2>Building a Custom Home: A Comprehensive Guide</h2>
        <p class="date">Posted on May 2nd, 2024</p>
        <p>Embark on the journey of building your dream home with our comprehensive guide. Discover the timeline, key stages, and factors influencing the construction of a custom home, tailored to your unique preferences and lifestyle.</p>
        <a href="{{ url_for('blog.custom_built_home_timeline') }}">Read the Full Guide</a>
    </article>    
    
</div>
{% endblock %}


C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\routes\main_routes.py:
import os
from datetime import datetime, time, timedelta
import icalendar
import pytz
import requests
from dateutil import parser
from flask import (Blueprint, Response, current_app, flash, jsonify,
                   redirect, render_template, request, session,
                   url_for)
from flask_login import current_user, login_required
from google_auth_oauthlib.flow import Flow
from markupsafe import Markup
from pytz import UTC

from app import csrf, db, mail
from app.forms import AcceptTOSForm, EstimateRequestForm, ContactForm
from app.models import Appointment, Estimator, Service, User, ContactFormSubmission
from app.modules.locations import get_locations
import random

main = Blueprint('main_routes', __name__)

@main.context_processor
def combined_context_processor():
    locations = get_locations()
    erf_form = EstimateRequestForm()
    return dict(locations=locations, erf_form=erf_form)

@main.route('/')
def index():
    # For regular user visitors, include the gallery logic
    image_folder = os.path.join(current_app.static_folder, 'images/gallery')
    gallery_images = [f for f in os.listdir(image_folder) if os.path.isfile(os.path.join(image_folder, f))]
    random.shuffle(gallery_images)

    page = int(request.args.get('page', 1))
    per_page = 5
    total_images = len(gallery_images)
    start = (page - 1) * per_page
    end = start + per_page

    paginated_images = gallery_images[start:end]
    has_more = end < total_images
    # Check for bot user agents in the request
    bot_agents = ['Googlebot', 'Bingbot', 'Slurp', 'DuckDuckBot', 'Baiduspider', 'YandexBot', 'Sogou']
    user_agent = request.headers.get('User-Agent', '')
    if any(bot in user_agent for bot in bot_agents):
        # Serve a static version of the homepage suitable for indexing
        return render_template('index.html', gallery_images=paginated_images, has_more=has_more, page=page)

    # For authenticated users, redirect based on their role
    if current_user.is_authenticated:
        if current_user.has_role('commercial'):
            return redirect(url_for('user.commercial_dashboard'))
        else:
            return redirect(url_for('user.dashboard'))

    # For regular user visitors, include the gallery logic
    image_folder = os.path.join(current_app.static_folder, 'images/gallery')
    gallery_images = [f for f in os.listdir(image_folder) if os.path.isfile(os.path.join(image_folder, f))]
    random.shuffle(gallery_images)

    page = int(request.args.get('page', 1))
    per_page = 5
    total_images = len(gallery_images)
    start = (page - 1) * per_page
    end = start + per_page

    paginated_images = gallery_images[start:end]
    has_more = end < total_images

    return render_template('index.html', gallery_images=paginated_images, has_more=has_more, page=page)

@main.route('/accept-terms', methods=['GET', 'POST'])
@login_required
def accept_terms():
    form = AcceptTOSForm()
    if form.validate_on_submit() and form.accept_tos.data:
        current_user.tos_accepted = True
        current_user.tos_accepted_on = datetime.utcnow()
        db.session.commit()
        flash('Thank you for accepting the terms of service.', 'success')
        return redirect(url_for('main_routes.index'))
    return render_template('accept_terms.html', form=form)

@main.route('/about')
def about():
    return render_template('aboutus.html')

@main.route('/services')
def services():
    return render_template('services.html')

@main.route('/contact', methods=['GET', 'POST'])
def contact():
    form = ContactForm()
    if form.validate_on_submit():
        submission = ContactFormSubmission(
            first_name=form.first_name.data,
            last_name=form.last_name.data,
            email=form.email.data,
            phone=form.phone.data,
            message=form.message.data
        )
        db.session.add(submission)
        db.session.commit()
        return redirect(url_for('main_routes.contact_confirmation'))
    return render_template('contact.html', form=form)

@main.route('/contact-confirmation')
def contact_confirmation():
    return render_template('contact_confirmation.html')   


@main.route('/request_estimate', methods=['POST'])
def request_estimate():
    form = EstimateRequestForm()

    if request.method == 'POST':
        current_app.logger.info(f"Form data received: {request.form}")

        selected_date = request.form.get('preferred_date')
        user_timezone_str = request.form.get('timezone', 'America/Denver')
        user_timezone = pytz.timezone(user_timezone_str)

        if selected_date:
            try:
                response = requests.post(
                    url_for('main_routes.get_available_time_slots', _external=True),
                    json={'date': selected_date, 'timezone': user_timezone_str},
                    headers={'Content-Type': 'application/json'},
                    timeout=10
                )
                response.raise_for_status()
                time_slots_data = response.json()
                time_slots = time_slots_data.get('timeSlots', [])

                form.preferred_time.choices = [(slot, convert_utc_to_local(slot, user_timezone)) for slot in time_slots]
            except requests.exceptions.RequestException as e:
                current_app.logger.error(f"Error fetching time slots: {e}")
                flash('There was an error fetching available time slots.', 'danger')
                return redirect(url_for('main_routes.index'))

        if form.validate_on_submit():
            current_app.logger.info("Form validation successful.")
            
            try:
                preferred_date_time = parser.isoparse(form.preferred_time.data)
                current_app.logger.info(f"Parsed preferred date and time: {preferred_date_time}")

                if preferred_date_time.tzinfo is None:
                    preferred_date_time_localized = user_timezone.localize(preferred_date_time)
                    current_app.logger.info(f"Localized preferred date and time: {preferred_date_time_localized}")
                else:
                    preferred_date_time_localized = preferred_date_time.astimezone(user_timezone)
                    current_app.logger.info(f"Converted preferred date and time to user's timezone: {preferred_date_time_localized}")

                preferred_date_time_utc = preferred_date_time_localized.astimezone(pytz.utc)
                current_app.logger.info(f"Preferred time (UTC): {preferred_date_time_utc}")
            except Exception as e:
                current_app.logger.error(f"Error parsing date and time: {e}")
                flash('There was an error with the selected date or time.', 'danger')
                return redirect(url_for('main_routes.index'))

            try:
                appointment = Appointment(
                    first_name=form.first_name.data,
                    last_name=form.last_name.data,
                    phone=form.phone.data,
                    email=form.email.data,
                    preferred_date_time=preferred_date_time_utc,
                    service_id=form.service.data,
                    estimator_id=form.estimator.data
                )
                db.session.add(appointment)
                db.session.commit()
                current_app.logger.info(f"Appointment created: {appointment}")

                flash('Your estimate request has been submitted.', 'success')
                return redirect(url_for('main_routes.estimate_submitted',
                                        estimator=form.estimator.data,
                                        date=preferred_date_time.strftime('%Y-%m-%d'),
                                        time=preferred_date_time.strftime('%H:%M')))
            except Exception as e:
                current_app.logger.error(f"Error creating appointment: {e}")
                flash('There was an error processing your request.', 'danger')
                return redirect(url_for('main_routes.index'))
        else:
            current_app.logger.info("Form validation failed.")
            for field, errors in form.errors.items():
                for error in errors:
                    current_app.logger.error(f"Error in {field}: {error}")

    return redirect(url_for('main_routes.index'))

def convert_utc_to_local(utc_time_str, user_timezone):
    utc_date_time = datetime.fromisoformat(utc_time_str.replace('Z', '+00:00'))
    local_date_time = utc_date_time.astimezone(user_timezone)
    return local_date_time.strftime('%Y-%m-%d %H:%M:%S')

def get_upcoming_appointments():
    now = datetime.utcnow()
    return Appointment.query.filter(Appointment.preferred_date_time > now).all()

@main.route('/api/upcoming_appointments')
@csrf.exempt
def api_upcoming_appointments():
    try:
        appointments = get_upcoming_appointments()
        if appointments is None:
            current_app.logger.info("No upcoming appointments found.")
            return jsonify([]), 200

        appointments_data = [{
            'start': appointment.preferred_date_time.replace(tzinfo=pytz.utc).isoformat(),
            'end': (appointment.preferred_date_time + timedelta(hours=1)).replace(tzinfo=pytz.utc).isoformat()
        } for appointment in appointments]
        return jsonify(appointments_data), 200
    except Exception as e:
        current_app.logger.error(f"An error occurred fetching appointments: {e}")
        return jsonify({'error': 'An error occurred fetching appointments'}), 500

@main.route('/get_available_time_slots', methods=['POST'])
@csrf.exempt
def get_available_time_slots():
    data = request.json
    current_app.logger.info(f"Received data: {data}")

    if 'date' not in data or 'timezone' not in data:
        current_app.logger.error('Missing date or timezone in request')
        return jsonify({'error': 'Missing date or timezone'}), 400

    try:
        selected_date = datetime.strptime(data['date'], '%Y-%m-%d').date()
        user_timezone_str = data['timezone']
        user_timezone = pytz.timezone(user_timezone_str)
        current_app.logger.info(f"User's timezone: {user_timezone_str}")

    except (ValueError, pytz.UnknownTimeZoneError) as e:
        current_app.logger.error(f"Error parsing date or timezone: {e}")
        return jsonify({'error': 'Invalid date or timezone format'}), 400

    company_timezone = pytz.timezone('America/Denver')
    business_start_time = time(8, 0)
    business_end_time = time(17, 0)

    start_time_local = datetime.combine(selected_date, business_start_time)
    end_time_local = datetime.combine(selected_date, business_end_time)

    start_time_localized = company_timezone.localize(start_time_local)
    end_time_localized = company_timezone.localize(end_time_local)

    start_time_utc = start_time_localized.astimezone(pytz.UTC)
    end_time_utc = end_time_localized.astimezone(pytz.UTC)

    time_slots = []
    current_time_utc = start_time_utc

    while current_time_utc < end_time_utc:
        existing_appointment = Appointment.query.filter_by(preferred_date_time=current_time_utc).first()
        
        if not existing_appointment:
            user_time_slot = current_time_utc.astimezone(user_timezone)
            time_slots.append(user_time_slot.isoformat())
        
        current_time_utc += timedelta(minutes=30)

    current_app.logger.info(f"Generated time slots in ISO format (UTC): {time_slots}")
    
    return jsonify({'timeSlots': time_slots})

@main.route('/estimate_submitted')
def estimate_submitted():
    referrer = request.args.get('referrer', url_for('main_routes.index'))
    estimator = request.args.get('estimator')
    date = request.args.get('date')
    time = request.args.get('time')

    time_obj = datetime.strptime(time, '%H:%M')
    formatted_time = time_obj.strftime('%I:%M %p')

    return render_template('estimate_submitted.html',
                           referrer=referrer,
                           estimator=estimator,
                           date=date,
                           time=formatted_time,
                           hide_estimate_form=True)

@main.route('/oauth2callback')
def oauth2callback():
    credentials_path = os.path.join(current_app.root_path, 'modules','credentials.json')
    print(f"Final path to credentials.json: {credentials_path}")
    flow = Flow.from_client_secrets_file(
        credentials_path,
        scopes=['https://www.googleapis.com/auth/gmail.send'],
        redirect_uri='https://www.ajtreepruning.com/oauth2callback')

    authorization_response = request.url
    flow.fetch_token(authorization_response=authorization_response)

    credentials = flow.credentials
    session['credentials'] = credentials_to_dict(credentials)

    return redirect('/')

def credentials_to_dict(credentials):
    return {'token': credentials.token,
            'refresh_token': credentials.refresh_token,
            'token_uri': credentials.token_uri,
            'client_id': credentials.client_id,
            'client_secret': credentials.client_secret,
            'scopes': credentials.scopes}
            
@main.route('/generate_ics')
def generate_ics():
    estimator = request.args.get('estimator')
    location = request.args.get('location')
    date = request.args.get('date')
    time = request.args.get('time')

    event = icalendar.Event()
    event.add('summary', f'Appointment with {estimator}')
    event.add('dtstart', datetime.strptime(f'{date} {time}', '%Y-%m-%d %I:%M %p'))
    event.add('dtend', datetime.strptime(f'{date} {time}', '%Y-%m-%d %I:%M %p') + timedelta(hours=1))
    event.add('location', location)
    event.add('description', f'Your appointment at {location}')

    cal = icalendar.Calendar()
    cal.add_component(event)

    ics_content = cal.to_ical()

    response = Response(ics_content, mimetype='text/calendar')
    response.headers['Content-Disposition'] = 'attachment; filename=appointment.ics'
    return response


C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\static\js\mutator.js:
document.addEventListener("DOMContentLoaded", function() {
    // Target container where you want the widget to be placed
    const targetContainer = document.getElementById('square-appointments-widget');

    // Options for the observer (which mutations to observe)
    const config = { childList: true, subtree: true };

    // Callback function to execute when mutations are observed
    const callback = function(mutationsList, observer) {
        for(let mutation of mutationsList) {
            if (mutation.type === 'childList') {
                // Check if the Square widget has been added
                const squareWidget = document.querySelector('.square-appointments-widget'); // Adjust the selector based on the actual widget's class or ID
                if (squareWidget) {
                    // Move the widget to the target container
                    targetContainer.appendChild(squareWidget);
                    observer.disconnect(); // Stop observing once the widget has been moved
                }
            }
        }
    };

    // Create an observer instance linked to the callback function
    const observer = new MutationObserver(callback);

    // Start observing the document body for configured mutations
    observer.observe(document.body, config);
});

C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\routes\admin.py:
# app/routes/admin.py
from flask import Blueprint, render_template, request, redirect, url_for, flash, current_app, make_response, jsonify
from flask_login import login_required, current_user
from app.modules.auth_manager import admin_required  # Assuming you have an admin_required decorator
from app.models import User, Estimator, Service, Appointment, ContactFormSubmission
from app.forms import ManageRolesForm, EditUserForm, EstimatorForm, EstimateRequestForm, ServiceOptionForm, CSRFTokenForm
from app.database import db
from werkzeug.utils import secure_filename
import os
from datetime import datetime, date, time, timedelta
from app.modules.indexing import generate_sitemap, submit_sitemap_to_bing
from app import csrf
from datetime import datetime, timedelta, timezone, time
import pytz

admin = Blueprint('admin', __name__, template_folder='templates')

@admin.context_processor
def combined_context_processor():
    locations = get_locations()
    erf_form = EstimateRequestForm()
    return dict(erf_form=erf_form, hide_estimate_form=True)

@admin.route('/dashboard')
@login_required
@admin_required
def admin_dashboard():
    # Fetch necessary data for the dashboard
    total_users = User.query.count()
    contact_form_submissions = ContactFormSubmission.query.order_by(ContactFormSubmission.submitted_at.desc()).all()

    # Fetch appointments within current month
    company_timezone = pytz.timezone('America/Denver')
    now_local = datetime.now(company_timezone)

    # Get the first day of the current month
    first_day = now_local.replace(day=1, hour=0, minute=0, second=0, microsecond=0)

    # Get the first day of the next month
    if now_local.month == 12:
        next_month = now_local.replace(year=now_local.year+1, month=1, day=1, hour=0, minute=0, second=0, microsecond=0)
    else:
        next_month = now_local.replace(month=now_local.month+1, day=1, hour=0, minute=0, second=0, microsecond=0)

    # Convert to UTC
    first_day_utc = first_day.astimezone(pytz.utc)
    next_month_utc = next_month.astimezone(pytz.utc)

    # Query appointments in this date range
    appointments = Appointment.query.filter(
        Appointment.preferred_date_time >= first_day_utc,
        Appointment.preferred_date_time < next_month_utc
    ).order_by(Appointment.preferred_date_time.asc()).all()

    # Convert appointment times to company's timezone (America/Denver)
    for appointment in appointments:
        if appointment.preferred_date_time:
            # Assuming preferred_date_time is stored in UTC
            utc_time = appointment.preferred_date_time.replace(tzinfo=pytz.utc)
            appointment.local_time = utc_time.astimezone(company_timezone)
        else:
            appointment.local_time = None

    form = CSRFTokenForm()  # Create an instance of the CSRFTokenForm

    return render_template(
        'admin/dashboard.html',
        total_users=total_users,
        contact_form_submissions=contact_form_submissions,
        appointments=appointments,
        form=form
    )

@admin.route('/user-management')
@login_required
@admin_required
def user_management():
    users = User.query.all()
    return render_template('admin/user_management.html', users=users)

@admin.route('/manage-roles/<int:user_id>', methods=['GET', 'POST'])
@login_required
@admin_required
def manage_roles(user_id):
    user = User.query.get_or_404(user_id)
    form = ManageRolesForm(obj=user)

    if form.validate_on_submit():
        user.roles = form.roles.data
        db.session.commit()
        flash('User roles updated successfully.', 'success')
        return redirect(url_for('admin.user_management'))

    return render_template('manage_roles.html', form=form, user=user)

@admin.route('/edit-user/<int:user_id>', methods=['GET', 'POST'])
@login_required
@admin_required
def edit_user(user_id):
    user = User.query.get_or_404(user_id)
    form = EditUserForm(obj=user)  # Pre-populate form with user data

    if form.validate_on_submit():
        user.username = form.username.data
        user.email = form.email.data
        # Update other fields as necessary
        db.session.commit()
        flash('User updated successfully.', 'success')
        return redirect(url_for('admin.user_management'))

    return render_template('admin/edit_user.html', form=form, user=user)

@admin.route('/estimator', methods=['GET', 'POST'])
@login_required
@admin_required
def admin_estimator():
    form = EstimatorForm()
    if form.validate_on_submit():
        
        estimator = Estimator(name=form.name.data)
        db.session.add(estimator)
        db.session.commit()
        
        return redirect(url_for('admin.admin_dashboard'))  # Redirect to admin dashboard or appropriate page
    return render_template('admin/estimator_form.html', hide_estimate_form=True, form=form)

@admin.route('/service', methods=['GET', 'POST'])
@login_required
@admin_required
def services():
    form = ServiceOptionForm()
    if form.validate_on_submit():
        current_app.logger.debug('Form validated successfully.')

        service = Service(
            name=form.name.data, 
            description=form.description.data, 
            display_order=form.display_order.data
        )
        current_app.logger.debug(f'Creating new Service: {service.name}')

        # Add the new Service instance to the session
        db.session.add(service)
        
        try:
            # Commit the session to save changes to the database
            db.session.commit()
            current_app.logger.debug('New Service added to the database successfully.')
            
            # Flash a success message
            flash('Service added successfully.', 'success')
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f'Error adding Service to the database: {e}')
            flash('Error adding Service. Please try again.', 'error')

        # Redirect to the 'admin.services' route
        return redirect(url_for('admin.services'))
    else:
        if form.errors:
            current_app.logger.debug(f'Form validation errors: {form.errors}')

    # Query all Service instances, ordered by display_order
    services = Service.query.order_by(Service.display_order).all()
    current_app.logger.debug(f'Loaded {len(services)} Services for display.')

    # Render the 'admin/floorplan.html' template
    return render_template('admin/floorplan.html', hide_estimate_form=True, form=form, services=services)

@admin.route('/generate-sitemap', methods=['GET'])
@login_required
@admin_required
def generate_sitemap_route():
    try:
        # Call the generate_sitemap function to create the sitemap
        generate_sitemap(current_app)
        flash('Sitemap generated and saved successfully.', 'success')
        
        # Optionally, submit the sitemap to Bing or any other search engine
        # submit_sitemap_to_bing('http://www.yourdomain.com/static/sitemap.xml')
        flash('Sitemap submitted to Bing successfully.', 'success')
    except Exception as e:
        flash(f'Error generating or submitting sitemap: {e}', 'error')
    
    return redirect(url_for('admin.admin_dashboard'))

@admin.route('/api/admin_appointments')
@csrf.exempt
@login_required
@admin_required
def admin_appointments():
    now = datetime.utcnow()
    appointments = Appointment.query.filter(
        Appointment.preferred_date_time >= now
    ).order_by(Appointment.preferred_date_time).all()

    appointments_data = [{
        'first_name': appointment.first_name,
        'last_name': appointment.last_name,
        'phone': appointment.phone,
        'email': appointment.email,
        'preferred_date_time': appointment.preferred_date_time.replace(tzinfo=pytz.utc).isoformat(),
        'service': appointment.service.name if appointment.service else 'N/A',
        'estimator': appointment.estimator.name if appointment.estimator else 'N/A',
        'start': appointment.preferred_date_time.replace(tzinfo=pytz.utc).isoformat(),
        'end': (appointment.preferred_date_time + timedelta(hours=1)).replace(tzinfo=pytz.utc).isoformat()  # Assuming each appointment lasts 1 hour
    } for appointment in appointments]

    return jsonify(appointments_data), 200

@admin.route('/delete_contact_submission/<int:id>', methods=['POST'])
@login_required
@admin_required
def delete_contact_submission(id):
    submission = ContactFormSubmission.query.get_or_404(id)
    db.session.delete(submission)
    db.session.commit()
    flash('Contact form submission deleted successfully.', 'success')
    return redirect(url_for('admin.admin_dashboard'))

@admin.route('/delete_appointment/<int:appointment_id>', methods=['POST'])
@login_required
@admin_required
def delete_appointment(appointment_id):
    appointment = Appointment.query.get_or_404(appointment_id)
    db.session.delete(appointment)
    db.session.commit()
    flash('Appointment deleted successfully.', 'success')
    return redirect(url_for('admin.admin_dashboard'))

C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\extensions.py:
# app/extensions.py
from flask_login import LoginManager
from flask_wtf.csrf import CSRFProtect, generate_csrf
from flask_mail import Mail
from flask_bcrypt import Bcrypt

login_manager = LoginManager()
csrf = CSRFProtect()
mail = Mail()
bcrypt = Bcrypt()


C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\dbl.py:
from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from app import Config, create_app, db

app = create_app()

# db.init_app(app)  # This line is not necessary if db has been initialized in create_app

with app.app_context():
    #db.drop_all()
    db.create_all()


C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\templates\base.html:
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no">
    <meta name="description" content="{% block description %}At Verso, we're not merely developing software; we're architecting an entire ecosystem.{% endblock %}">
    <meta property="og:type" content="website">
    <meta property="og:image" content="{{ url_for('static', filename='images/logo.png') }}">
    <meta name="twitter:card" content="summary_large_image">
    <link rel="icon" type="image/png" sizes="32x32" href="{{ url_for('static', filename='images/favicon-32x32.png') }}">
    <link rel="icon" type="image/png" sizes="16x16" href="{{ url_for('static', filename='images/favicon-16x16.png') }}">
    <link rel="apple-touch-icon" sizes="180x180" href="{{ url_for('static', filename='images/apple-touch-icon.png') }}">
    <link rel="icon" type="image/png" sizes="192x192" href="{{ url_for('static', filename='images/android-chrome-192x192.png') }}">
    <link rel="icon" type="image/png" sizes="512x512" href="{{ url_for('static', filename='images/android-chrome-512x512.png') }}">
    <link rel="manifest" href="{{ url_for('static', filename='site.webmanifest') }}">
    <link rel="mask-icon" href="{{ url_for('static', filename='images/safari-pinned-tab.svg') }}" color="#5bbad5">
    <meta name="theme-color" content="#333333">
    <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='css/base.css') }}">
    <title>{% block title %}DemoSite{% endblock %}</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/base.css') }}">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <script src="{{ url_for('static', filename='js/fullcalendar/index.global.min.js') }}"></script>
    <script src="{{ url_for('static', filename='js/calendar.js') }}"></script>
    <script src="https://polyfill-fastly.io/v3/polyfill.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script>
        // Utility function to get the CSRF token from the cookie
        function getCsrfToken() {
            const name = 'csrf_token=';
            const decodedCookie = decodeURIComponent(document.cookie);
            const cookies = decodedCookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                let cookie = cookies[i].trim();
                if (cookie.indexOf(name) === 0) {
                    return cookie.substring(name.length, cookie.length);
                }
            }
            return null;
        }

        // Example: Set up CSRF token for AJAX requests with jQuery
        $.ajaxSetup({
            beforeSend: function(xhr, settings) {
                if (!/^(GET|HEAD|OPTIONS|TRACE)$/i.test(settings.type) && !this.crossDomain) {
                    xhr.setRequestHeader('X-CSRFToken', getCsrfToken());
                }
            }
        });
    </script>
    {% block additional_css %}{% endblock %}
    {% block head %}{% endblock %} <!-- Additional head content -->
</head>
<body {% block body_attributes %}{% endblock %}>
    <div class="alert-bar">
        Demo Site
        <a href="{{ url_for('main_routes.contact') }}" class="btn btn-23">Contact</a>
    </div>    
    <header>
        <div class="logo">
            <a href="{{ url_for('main_routes.index') }}">
                <img src="{{ url_for('static', filename='images/logo.png') }}" alt="Logo">
            </a>
        </div>
        <h1 class="title-font"><a href="{{ url_for('main_routes.index') }}" style="color: #fff; text-decoration: none;">Verso Backend</a></h1>
        <div id="menuToggle">
            <input type="checkbox" />
            <span></span>
            <span></span>
            <span></span>
            <nav id="menu">
                <ul>
                    <li><a href="{{ url_for('main_routes.index') }}">Home</a></li>
                    
                    <!-- About Dropdown -->
                    <li class="dropdown">
                        <a href="{{ url_for('main_routes.about') }}" class="dropbtn">About</a>
                        <div class="dropdown-content">
                            <a href="{{ url_for('blog.show_blog') }}">Blog Posts</a>
                        </div>
                    </li>
                    
                    <!-- Services Dropdown -->
                    <li class="dropdown">
                        <a href="{{ url_for('main_routes.services') }}" class="dropbtn">Services</a>
                        <div class="dropdown-content">
                        </div>
                    </li>
                    
                    <li><a href="{{ url_for('main_routes.contact') }}">Contact</a></li>
                    
                    {% if current_user.is_authenticated %}
                        <!-- User Dropdown -->
                        <li class="dropdown">
                            <a href="#" class="dropbtn">Welcome, {{ current_user.first_name }}</a>
                            <div class="dropdown-content">
                                <a href="{{ url_for('auth.logout') }}">Logout</a>
                                {% if current_user.has_role('admin') %}
                                    <div class="divider"></div>
                                    <a href="{{ url_for('admin.admin_dashboard') }}">Admin Dashboard</a>
                                    <a href="{{ url_for('admin.user_management') }}">User Management</a>
                                {% endif %}
                            </div>
                        </li>
    
                    {% else %}
                        <li><a href="{{ url_for('auth.login') }}">Login</a></li>
                        <li><a href="{{ url_for('auth.register') }}">Register</a></li>
                    {% endif %}
                </ul>
                <div class="small-spacer"></div>
                <div class="notification-icon">
                    <a href="#" id="notification-icon">
                        Notifications
                        {% if unread_notifications_count|default(0) > 0 %}
                            <span class="badge">{{ unread_notifications_count }}</span>
                        {% endif %}
                    </a>
                    <!-- Notification Dropdown -->
                    <div class="notification-dropdown" id="notification-dropdown">
                        <ul id="notification-list">
                            <!-- Notifications will be dynamically loaded here -->
                            <li>Loading notifications...</li>
                        </ul>
                        <button id="mark-all-read">Mark All as Read</button>
                    </div>
                </div>
            </nav>
        </div>
    </header>

    {% with messages = get_flashed_messages(with_categories=true) %}
        {% if messages %}
            <div class="flash-messages">
                {% for category, message in messages %}
                    <div class="alert alert-{{ category }}">
                        {{ message }}
                    </div>
                {% endfor %}
            </div>
        {% endif %}
    {% endwith %}

    <div class="container">
        {% block content %}
            {% block body %}{% endblock %}
            <!-- Main content will be overridden in child templates -->
        {% endblock %}
    </div>
{% if not hide_estimate_form %}
<div class="wrapper" id="appointment-form">
    <div class="form-heading">
        <h2>Book an Appointment Directly with US</h2>
    </div>

    <!-- Step 1: Personal Information -->
    <div id="step-1" class="left-container">
        <form id="personal-info-form" class="form-box" method="POST" action="{{ url_for('main_routes.request_estimate') }}">
            {{ erf_form.hidden_tag() }}
            <fieldset class="fieldset">
                <legend class="legend">Personal Information:</legend>

                <div class="form-group">
                    {{ erf_form.first_name.label(class="form-label") }}<span class="text-danger">* Required</span>
                    {{ erf_form.first_name(class="form-control", required=True) }}
                    {% if erf_form.first_name.errors %}
                        <div class="form-error">
                            {% for error in erf_form.first_name.errors %}
                                <span class="text-danger">{{ error }}</span>
                            {% endfor %}
                        </div>
                    {% endif %}
                </div>

                <div class="form-group">
                    {{ erf_form.last_name.label(class="form-label") }}<span class="text-danger">* Required</span>
                    {{ erf_form.last_name(class="form-control", required=True) }}
                    {% if erf_form.last_name.errors %}
                        <div class="form-error">
                            {% for error in erf_form.last_name.errors %}
                                <span class="text-danger">{{ error }}</span>
                            {% endfor %}
                        </div>
                    {% endif %}
                </div>

                <div class="form-group">
                    {{ erf_form.phone.label(class="form-label") }}<span class="text-danger">* Required</span>
                    {{ erf_form.phone(class="form-control", required=True) }}
                    {% if erf_form.phone.errors %}
                        <div class="form-error">
                            {% for error in erf_form.phone.errors %}
                                <span class="text-danger">{{ error }}</span>
                            {% endfor %}
                        </div>
                    {% endif %}
                </div>

                <div class="form-group">
                    {{ erf_form.email.label(class="form-label") }}<span class="text-danger">* Required</span>
                    {{ erf_form.email(class="form-control", required=True) }}
                    {% if erf_form.email.errors %}
                        <div class="form-error">
                            {% for error in erf_form.email.errors %}
                                <span class="text-danger">{{ error }}</span>
                            {% endfor %}
                        </div>
                    {% endif %}
                </div>
            </fieldset>
            <!-- Next Button -->
            <div class="form-group">
                <button type="button" class="btn btn-primary" id="next-button">Next</button>
            </div>
        </form>
    </div>

    <!-- Step 2: Appointment Information (Initially Hidden) -->
    <div id="step-2" class="left-container" style="display: none;">
        <form id="appointment-form" class="form-box" action="{{ url_for('main_routes.request_estimate') }}" method="post">
            {{ erf_form.hidden_tag() }}
            
            <!-- Hidden inputs for personal info from Step 1 -->
            <input type="hidden" id="hidden_first_name" name="first_name">
            <input type="hidden" id="hidden_last_name" name="last_name">
            <input type="hidden" id="hidden_phone" name="phone">
            <input type="hidden" id="hidden_email" name="email">
            
            <fieldset class="fieldset">
                <legend class="legend">Appointment Information:</legend>
                
                <!-- Estimator Selection -->
                <div class="form-group">
                    <label for="estimator" class="form-label">Select Estimator</label><span class="text-danger">* Required</span>
                    {{ erf_form.estimator(class="form-control", required=True) }}
                    {% if erf_form.estimator.errors %}
                        <div class="form-error">
                            {% for error in erf_form.estimator.errors %}
                                <span class="text-danger">{{ error }}</span>
                            {% endfor %}
                        </div>
                    {% endif %}
                </div>
                
                <!-- Service Selection -->
                <div class="form-group">
                    {{ erf_form.service.label(class="form-label") }}<span class="text-danger">* Required</span>
                    {{ erf_form.service(class="form-control", required=True) }}
                    {% if erf_form.service.errors %}
                        <div class="form-error">
                            {% for error in erf_form.service.errors %}
                                <span class="text-danger">{{ error }}</span>
                            {% endfor %}
                        </div>
                    {% endif %}
                </div>

                <!-- Preferred Date -->
                <div class="form-group">
                    {{ erf_form.preferred_date.label(class="form-label") }}<span class="text-danger">* Required</span>
                    <input type="date" id="{{ erf_form.preferred_date.id }}" name="{{ erf_form.preferred_date.name }}" class="form-control" required>
                    {% if erf_form.preferred_date.errors %}
                        <div class="form-error">
                            {% for error in erf_form.preferred_date.errors %}
                                <span class="text-danger">{{ error }}</span>
                            {% endfor %}
                        </div>
                    {% endif %}
                </div>

                <!-- Preferred Time -->
                <div class="form-group">
                    {{ erf_form.preferred_time.label(class="form-label") }}<span class="text-danger">* Required</span>
                    <select id="preferred_time" name="{{ erf_form.preferred_time.name }}" class="form-control" required>
                        <option value="">Select a time</option>
                    </select>
                    {% if erf_form.preferred_time.errors %}
                        <div class="form-error">
                            {% for error in erf_form.preferred_time.errors %}
                                <span class="text-danger">{{ error }}</span>
                            {% endfor %}
                        </div>
                    {% endif %}
                </div>
            </fieldset>
            
            <!-- Submit Button -->
            <div class="form-group">
                <input type="hidden" name="referrer" value="{{ request.url }}">
                {{ erf_form.submit(class="btn btn-primary") }}
            </div>
        </form>
    </div>

    <!-- Calendar (Initially Hidden) -->
    <div class="right-container" style="display: none;" id="calendar-container">
        <div id="calendar" class="calendar-box"></div>
    </div>
</div>                 
{% endif %}

{% block scripts %}{% endblock %}

<footer>
    <p>&copy; <span id="current-year"></span> Verso Industries. All rights reserved.</p>
    <p>&copy; <span id="current-year-2"></span> Empowered by our own backend!</a>.</p>
</footer>
    
<script>
    // Get the current year
    const year = new Date().getFullYear();

    // Set the current year in the footer
    document.getElementById('current-year').textContent = year;
    document.getElementById('current-year-2').textContent = year;
</script>

<script>
    $(document).ready(function() {
        // Close sidebar when clicking outside
        $(document).on('click', function(event) {
            const $menu = $('#menu');
            const $menuToggle = $('#menuToggle input');
            const $target = $(event.target);

            // Check if the menu is open and the click is outside both the menu and toggle
            if ($menuToggle.is(':checked') && !$target.closest('#menu').length && !$target.closest('#menuToggle').length) {
                $menuToggle.prop('checked', false); // Uncheck the toggle to close the menu
            }
        });

        // Ensure dropdowns don’t trigger the outside click closure
        $('.dropdown-content, .notification-dropdown').on('click', function(event) {
            event.stopPropagation(); // Prevents clicks inside dropdowns from closing the menu
        });
    });
</script>
    
<script src="{{ url_for('static', filename='js/calendar.js') }}"> defer</script>    
    
</body>
</html>


C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\templates\login.html:
{% extends 'base.html' %}

{% block additional_css %}
    <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='css/register.css') }}">
{% endblock %}

{% block title %}Login{% endblock %}

{% block content %}
<div class="login-container">
    <div class="login-box">
        <!-- Flash Messages Display -->
        {% with messages = get_flashed_messages(with_categories=true) %}
        {% if messages %}
            {% for category, message in messages %}
            <div class="alert alert-{{ category }} alert-dismissible fade show" role="alert">
                {{ message }}
                <button type="button" class="close" data-dismiss="alert" aria-label="Close">
                    <span aria-hidden="true">&times;</span>
                </button>
            </div>
            {% endfor %}
        {% endif %}
        {% endwith %}

        <h2>Login</h2>
        <form method="POST" action="{{ url_for('auth.login') }}">
            {{ form.hidden_tag() }}
            <div class="form-group">
                {{ form.email.label(class="form-control-label") }}
                {{ form.email(class="form-control") }}
            </div>
            <div class="form-group">
                {{ form.password.label(class="form-control-label") }}
                {{ form.password(class="form-control") }}
            </div>
            <div class="form-group">
                <button type="submit" class="btn btn-primary">Login</button>
            </div>
        </form>
        <!-- Registration Link -->
        <div class="form-group">
            <p>Don't have an account? <a href="{{ url_for('auth.register') }}" class="btn btn-primary">Register</a></p>
        </div>
    </div>
</div>
{% endblock %}


C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\templates\accept_terms.html:
<!-- app/templates/accept_terms.html -->

{% extends 'base.html' %}

{% block content %}
<div class="container">
    <h1>Terms of Service</h1>
    <p>Please read and accept the terms of service to continue using the platform.</p>

    <!-- Display the terms of service text here -->
    <div class="tos-text">
        <!-- Include your terms of service text here -->
        <p>Your terms of service content goes here...</p>
    </div>

    <form method="post">
        {{ form.hidden_tag() }}
        {{ form.accept_tos.label }} {{ form.accept_tos() }}
        {% for error in form.accept_tos.errors %}
            <span class="text-danger">{{ error }}</span>
        {% endfor %}
        {{ form.submit() }}
    </form>
</div>
{% endblock %}


C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\Procfile:
web: gunicorn "app:create_app()"

C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\.env:
FLASK_APP=app
SECRET_KEY=2894565132464132168746541065496
FLASK_ENV=development

C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\templates\request_estimate.html:
{% if not hide_estimate_form %}
<div class="container">
    <!-- Left Container for Form and Google Maps -->
    <div class="left-container">
        <form id="estimate-request-form" class="form-container" action="{{ url_for('main_routes.request_estimate') }}" method="post">
            {{ erf_form.hidden_tag() }}

            <!-- Personal Information Section -->
            <fieldset class="fieldset">
                <legend class="legend">Personal Information:</legend>
                <div class="form-group">
                    {{ erf_form.first_name.label(class="form-label") }}
                    {{ erf_form.first_name(class="form-control") }}
                </div>
                <div class="form-group">
                    {{ erf_form.last_name.label(class="form-label") }}
                    {{ erf_form.last_name(class="form-control") }}
                </div>
                <div class="form-group">
                    {{ erf_form.phone.label(class="form-label") }}
                    {{ erf_form.phone(class="form-control") }}
                </div>
                <div class="form-group">
                    {{ erf_form.email.label(class="form-label") }}
                    {{ erf_form.email(class="form-control") }}
                </div>
            </fieldset>

            <!-- Appointment Information Section -->
            <fieldset class="fieldset">
                <legend class="legend">Appointment Information:</legend>
                <div class="form-group location-group">
                    {{ erf_form.location.label(class="form-label") }}
                    {{ erf_form.location(class="form-control") }}
                    <button id="confirm-location" type="button" class="btn btn-info">Confirm Location</button>
                </div>
                <!-- Estimator Selection Section -->
                <div class="form-group">
                    <label for="estimator" class="form-label">Select Estimator</label>
                    {{ erf_form.estimator(class="form-control") }}
                </div>
                <div class="form-group">
                    {{ erf_form.preferred_date.label(class="form-label") }}
                    {{ erf_form.preferred_date(class="form-control") }}
                </div>
                <div class="form-group">
                    {{ erf_form.preferred_time.label(class="form-label") }}
                    {{ erf_form.preferred_time(class="form-control") }}
                </div>
            </fieldset>

            <!-- Google reCAPTCHA Widget -->
            <div class="g-recaptcha" data-sitekey="6LdrGq4pAAAAAEIyITrA-BIp91IAxgPGu1Kfpntt"></div>
            
            <!-- Submit Button -->
            <div class="form-group">
                {{ erf_form.submit(class="btn btn-primary") }}
            </div>
        </form>
        
        <!-- Google Maps Container -->
        <div id="map" class="map-container"></div>
    </div>

    <!-- Right Container for Calendar -->
    <div class="right-container">
        <div id="calendar" class="calendar-container"></div>
    </div>
</div>
{% endif %}

C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\templates\create_booking.html:
<!-- templates/create_booking.html -->
{% extends "base.html" %}

{% block additional_css %}
<link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='css/cbooking.css') }}">
{% endblock %}

{% block content %}
<div class="container">
    <h2>Create a Booking</h2>
    <form action="{{ url_for('booking.create_booking') }}" method="post">
        <div class="form-group">
            <label for="service_id">Service:</label>
            <select name="service_id" id="service_id" required>
                <!-- Dynamically populate services and pre-select if a service is provided -->
                {% for service in services %}
                <option value="{{ service.id }}" {% if selected_service and selected_service.id == service.id %}selected{% endif %}>{{ service.name }}</option>
                {% endfor %}
            </select>
        </div>

        <div class="form-group">
            <label for="team_member_id">Team Member:</label>
            <select name="team_member_id" id="team_member_id" required>
                <!-- Dynamically populate team members -->
                {% for member in team_members %}
                <option value="{{ member.id }}">{{ member.name }}</option>
                {% endfor %}
            </select>
        </div>

        <div id='calendar'></div>

        <div class="form-group">
            <input type="submit" value="Create Booking" class="btn btn-primary">
        </div>
    </form>
</div>
{% endblock %}

{% block scripts %}
<script>
    var csrfToken = "{{ csrf_token() }}";
    var selectedServiceId = "{{ selected_service.id if selected_service }}";
    var selectedTeamMemberId = "{{ request.form['team_member_id'] if request.form['team_member_id'] }}";
</script>
<script src="{{ url_for('static', filename='js/calendar.js') }}"></script>
{% endblock %}



C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\directory_html.py:
import os
import concurrent.futures
import threading

def is_ignored_path(path, ignore_patterns):
    # Split the path into parts and check if any part matches the ignore patterns
    path_parts = path.split(os.sep)
    return any(part in ignore_patterns for part in path_parts)

def process_file(root, file, ignore_patterns):
    if any(file.endswith(pattern) for pattern in ignore_patterns):
        return None

    file_path = os.path.join(root, file)
    content_lines = [f"{file_path}:\n"]
    try:
        with open(file_path, 'r', encoding='utf-8') as content_file:
            content = content_file.read()
            content_lines.append(content)
    except UnicodeDecodeError:
        content_lines.append("<Binary file or unsupported encoding>\n")
    except Exception as e:
        content_lines.append(f"<Error reading file: {e}>\n")
    content_lines.append("\n\n")
    return content_lines

def build_directory_contents(startpath, output_file, ignore_patterns):
    num_workers = os.cpu_count() * 4  # Heuristic for I/O-bound tasks

    contents = []
    with concurrent.futures.ThreadPoolExecutor(max_workers=num_workers) as executor:
        future_to_file = {executor.submit(process_file, root, file, ignore_patterns): file
                          for root, dirs, files in os.walk(startpath)
                          for file in files if not is_ignored_path(root, ignore_patterns)}

        for future in concurrent.futures.as_completed(future_to_file):
            file_content = future.result()
            if file_content is not None:
                contents.extend(file_content)

    with open(output_file, 'w', encoding='utf-8') as out:
        out.writelines(contents)

# Replace 'your/code/repository/path' with the actual path to your code repository
code_repository_path = 'C:\\Users\\zimme\\OneDrive\\Documents\\GitHub\\agilesnipe'
output_file = 'output_main.txt'
ignore_patterns = ['venv', '.py', '.jpg', '.png', '.js', 'docs', '.css', '.gitattributes', '__pycache__', 'instance', 'web_handlers.py', 'tests', 'migrations', '.gitattributes', 'README.md', 'flask_stripe', 'dbc.py', 'run.py', '.git', 'docs', 'directory_markdown.py', '.txt']

build_directory_contents(code_repository_path, output_file, ignore_patterns)

print(f"Directory contents have been written to {output_file}")


C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\modules\utils.py:
from PIL import Image
import io
from PIL import UnidentifiedImageError

def compress_image(image_path, quality=40, size=(1200, 1200), output_format=None):
    output = io.BytesIO()
    try:
        with Image.open(image_path) as img:
            if not output_format:
                output_format = img.format
            img.thumbnail(size)
            img.save(output, format=output_format, quality=quality)
            output.seek(0)
        return output
    except FileNotFoundError:
        print(f"File {image_path} not found.")
    except UnidentifiedImageError:
        print(f"Cannot identify image file {image_path}.")
    except Exception as e:
        print(f"Error compressing image: {e}")
    return None


C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\templates\index.html:
{% extends "base.html" %}

{% block additional_css %}
<link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='css/home.css') }}">
{% endblock %}

{% block head %}
  
{% endblock %}

{% block scripts %}
<script>
  document.addEventListener('DOMContentLoaded', function () {
      const lightbox = document.getElementById('lightbox');
      const lightboxImg = document.getElementById('lightbox-img');
      const lightboxClose = document.querySelector('.lightbox-close');

      // Function to attach lightbox event listeners to anchor tags
      function attachLightboxListeners(links) {
          links.forEach(link => {
              link.addEventListener('click', function (event) {
                  event.preventDefault(); // Prevent default link behavior
                  lightbox.style.display = 'flex'; // Show the lightbox
                  lightboxImg.src = this.href; // Set the image in the lightbox
              });
          });
      }

      // Initial attachment of lightbox event listeners
      const initialLinks = document.querySelectorAll('.gallery-container a');
      attachLightboxListeners(initialLinks);

      // Close the lightbox when clicking on the close button
      lightboxClose.addEventListener('click', function () {
          lightbox.style.display = 'none';
      });

      // Close the lightbox when clicking outside the image
      lightbox.addEventListener('click', function (event) {
          if (event.target !== lightboxImg) {
              lightbox.style.display = 'none';
          }
      });

      // Lazy loading images
      const lazyLoad = (image) => {
          image.src = image.dataset.src;
          image.onload = () => {
              image.classList.add('lazy-loaded');
          };
      };

      const observer = new IntersectionObserver((entries, observer) => {
          entries.forEach(entry => {
              if (entry.isIntersecting) {
                  lazyLoad(entry.target);
                  observer.unobserve(entry.target);
              }
          });
      });

      document.querySelectorAll('img.lazy').forEach(image => {
          observer.observe(image);
      });

      // Load more functionality
      const loadMoreButton = document.getElementById('load-more');
      if (loadMoreButton) {
          loadMoreButton.addEventListener('click', function () {
              const page = this.getAttribute('data-page');
              fetch(`{{ url_for('main_routes.index') }}?page=${page}`)
                  .then(response => response.text())
                  .then(data => {
                      const parser = new DOMParser();
                      const doc = parser.parseFromString(data, 'text/html');
                      const newLinks = doc.querySelectorAll('#gallery-container a');
                      const hasMore = doc.querySelector('#load-more');

                      newLinks.forEach(link => {
                          document.getElementById('gallery-container').appendChild(link);
                          const img = link.querySelector('img.lazy');
                          observer.observe(img);
                      });

                      // Attach lightbox listeners to new links
                      attachLightboxListeners(newLinks);

                      if (hasMore) {
                          this.setAttribute('data-page', parseInt(page) + 1);
                      } else {
                          this.remove();
                      }
                  });
          });
      }
  });
</script>
{% endblock %}

{% block title %}{% endblock %}

{% block description %}  {% endblock %}

{% block content %}
<div class="section-spacer"></div>

<section id="hero-image">
  <div class="image-container">
    <img src="{{ url_for('static', filename='images/hero-bg.jpg') }}" alt="Custom Business Website">
    <div class="image-overlay"></div>
    <div class="hero-content">
      <h1></h1>
      <p></p>
    </div>
  </div>
</section>

<div class="small-spacer"></div>



<div class="section-spacer"></div>

{% endblock %}


C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\routes\user.py:
from flask import Blueprint, render_template, redirect, url_for, flash, request, current_app, session, jsonify
from flask_login import login_user, logout_user, login_required, current_user
import app
import os
from app import db, mail, bcrypt  # Adjust 'app' to your actual app's name
from app.models import User
from app.forms import RegistrationForm, LoginForm, SettingsForm, EstimateRequestForm
from flask_mail import Message
from datetime import datetime, timedelta, date
import logging
from sqlalchemy import and_, cast, String

user = Blueprint('user', __name__)

@user.context_processor
def combined_context_processor():
    erf_form = EstimateRequestForm()
    return dict(erf_form=erf_form)

@user.route('/reset_password', methods=['POST'])
def reset_password():
    token = request.form.get('token')
    password = request.form.get('password')
    user = User.verify_reset_token(token)
    if user:
        hashed_password = bcrypt.generate_password_hash(password).decode('utf-8')
        user.password = hashed_password
        db.session.commit()
        flash('Your password has been updated!', 'success')
        return redirect(url_for('auth.login'))
    else:
        flash('That is an invalid or expired token', 'warning')
        return redirect(url_for('main.register'))

@user.route('/settings', methods=['GET', 'POST'])
@login_required
def settings():
    settings_form = SettingsForm()

    if settings_form.validate_on_submit():
        current_user.email = settings_form.email.data
        current_user.bio = settings_form.bio.data
        current_user.location = settings_form.location.data

        if settings_form.password.data:
            current_user.set_password(settings_form.password.data)  # Assuming you have a set_password method

        db.session.commit()
        flash('Your changes have been saved.')
        return redirect(url_for('main.settings'))

    elif request.method == 'GET':
        settings_form.email.data = current_user.email
        settings_form.bio.data = current_user.bio
        settings_form.location.data = current_user.location

    return render_template('settings.html', settings_form=settings_form)

@user.route('/dashboard')
@login_required
def dashboard():

    return render_template('UserDashboard/user_dashboard.html')


@user.route('/dashboard/commercial')
@login_required
def commercial_dashboard():
    if not current_user.has_role('commercial'):
        flash('Access denied. This area is for commercial users only.', 'danger')
        return redirect(url_for('user.dashboard'))


    return render_template(
        'UserDashboard/commercial_dashboard.html'
    )


C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\templates\aboutus.html:
{% extends 'base.html' %}

{% block additional_css %}
<link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='css/about.css') }}">
{% endblock %}

{% block content %}

{% endblock %}


C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\run.py:
from app import create_app  # You'll create a create_app function in __init__.py

app = create_app()

if __name__ == '__main__':
    app.run(debug=True)


C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\modules\auth_manager.py:
from flask import flash, redirect, url_for
from flask_login import UserMixin, LoginManager, current_user
from functools import wraps
from app.database import db
from app.models import User
from app import login_manager

@login_manager.user_loader
def load_user(user_id):
    return User.query.get(int(user_id))

def admin_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not current_user.is_authenticated or not current_user.has_role('admin'):
            flash('You do not have permission to view this page.', 'warning')
            return redirect(url_for('auth.login'))  # Replace 'auth.login' with the appropriate route for login
        return f(*args, **kwargs)
    return decorated_function


C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\static\js\slider.js:
var slideIndex = 1;
showSlides(slideIndex);

// Next/previous controls
function moveSlide(n) {
  showSlides(slideIndex += n);
}

// Thumbnail image controls
function currentSlide(n) {
showSlides(slideIndex = n);
}

function showSlides(n) {
  var i;
  var slides = document.getElementsByClassName("carousel-slide");
  var dots = document.getElementsByClassName("dot");

  if (n > slides.length) {slideIndex = 1}
  if (n < 1) {slideIndex = slides.length}

  // Hide all slides
  for (i = 0; i < slides.length; i++) {
    slides[i].style.display = "none";  
  }

  // Remove the "active" class from all dots
  for (i = 0; i < dots.length; i++) {
    dots[i].className = dots[i].className.replace(" active", "");
  }

  // Show the current slide and add "active" class to the corresponding dot
  slides[slideIndex-1].style.display = "block";  
  dots[slideIndex-1].className += " active";
}

document.querySelector('.hero-carousel').addEventListener('touchmove', function(e) {
  // Determine swipe direction
  var touch = e.touches[0];
  var change = touch.clientX - touchStartX; // touchStartX is where the swipe started
  var isHorizontalSwipe = Math.abs(change) > Math.abs(touch.clientY - touchStartY);

  // Prevent vertical scrolling if it's a horizontal swipe
  if (isHorizontalSwipe) {
      e.preventDefault();
  }
}, { passive: false });


// Optional: Add auto-slide functionality
var slideInterval = setInterval(function() { moveSlide(1); }, 3000); // Change image every 3 seconds


C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\static\js\appointment.js:
function createICSContent(appointment) {
    try {
        if (!appointment.preferred_date_time) {
            throw new Error('preferred_date_time is undefined');
        }

        const startDateTime = new Date(appointment.preferred_date_time);
        if (isNaN(startDateTime.getTime())) {
            throw new Error(`Invalid start date value: ${appointment.preferred_date_time}`);
        }

        const endDateTime = new Date(startDateTime.getTime() + 60 * 60000); // Assuming 1 hour appointments

        // Convert the dates to ISO strings without dashes, colons, and milliseconds
        const startISO = startDateTime.toISOString().replace(/-|:|\.\d\d\d/g, '');
        const endISO = endDateTime.toISOString().replace(/-|:|\.\d\d\d/g, '');

        const icsContent = [
            'BEGIN:VCALENDAR',
            'VERSION:2.0',
            'BEGIN:VEVENT',
            `DTSTART:${startISO}`,
            `DTEND:${endISO}`,
            `SUMMARY:${appointment.first_name} ${appointment.last_name}`,
            `DESCRIPTION:Appointment with ${appointment.first_name} ${appointment.last_name}. Service: ${appointment.service ? appointment.service : 'N/A'}.`,
            'END:VEVENT',
            'END:VCALENDAR'
        ].join('\n');

        return icsContent;
    } catch (error) {
        console.error('Error creating ICS content:', error, appointment);
        return '';
    }
}

function fetchAppointments() {
    fetch('api/admin_appointments', {
        credentials: 'include'  // Include cookies for session authentication
    })
    .then(response => {
        if (!response.ok) {
            console.error(`Server returned status ${response.status}`);
            throw new Error('Network response was not ok');
        }
        return response.json();
    })
    .then(data => {
        const appointmentsList = document.getElementById('appointmentsList');
        appointmentsList.innerHTML = ''; // Clear existing appointments
        data.forEach(appointment => {
            try {
                if (!appointment.preferred_date_time) {
                    console.warn('Skipping appointment due to missing preferred_date_time:', appointment);
                    return; // Skip this appointment
                }

                const dateTime = new Date(appointment.preferred_date_time);
                if (isNaN(dateTime.getTime())) {
                    throw new Error(`Invalid date value: ${appointment.preferred_date_time}`);
                }

                // Convert the dateTime to the user's local timezone
                const userTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
                const localDateTime = dateTime.toLocaleString('en-US', { timeZone: userTimezone });
                const formattedDateTime = new Date(localDateTime).toLocaleString('en-US', {
                    month: 'short',
                    day: '2-digit',
                    year: 'numeric',
                    hour: 'numeric',
                    minute: '2-digit',
                    hour12: true
                });

                const icsContent = createICSContent(appointment);
                const icsBlob = new Blob([icsContent], { type: 'text/calendar' });
                const icsUrl = URL.createObjectURL(icsBlob);

                const li = document.createElement('li');
                li.innerHTML = `<h3>${appointment.first_name} ${appointment.last_name}</h3> - 
                                <h4><a href="tel:${appointment.phone}">${appointment.phone}</a></h4> -
                                <h4>${appointment.email}</h4>
                                <h4><a href="${icsUrl}" download="${appointment.first_name}_${appointment.last_name}_appointment.ics">${formattedDateTime}</a></h4> - 
                                <h4>Service: ${appointment.service ? appointment.service : 'N/A'}</h4> - 
                                <h4>Estimator: ${appointment.estimator ? appointment.estimator : 'N/A'}</h4>
                                <button onclick="deleteAppointment(${appointment.id})">Delete</button>`;
                appointmentsList.appendChild(li);
            } catch (error) {
                console.error('Error processing appointment:', error, appointment);
            }
        });
    })
    .catch(error => {
        console.error('Fetch error:', error);
    });
}

function deleteAppointment(appointmentId) {
    const csrfToken = document.querySelector('meta[name="csrf-token"]').getAttribute('content');
    fetch(`api/appointments/delete`, {
        method: 'POST',
        credentials: 'include',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': csrfToken
        },
        body: JSON.stringify({ appointment_id: appointmentId })
    })
    .then(response => {
        if (!response.ok) {
            console.error(`Server returned status ${response.status}`);
            throw new Error('Network response was not ok');
        }
        return response.json();
    })
    .then(data => {
        if (data.status === 'success') {
            fetchAppointments(); // Refresh the appointments list
        } else {
            console.error('Error deleting appointment:', data.message);
        }
    })
    .catch(error => {
        console.error('Fetch error:', error);
    });
}

// Fetch appointments every minute
setInterval(fetchAppointments, 60000);
fetchAppointments(); // Initial fetch

C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\modules\__init__.py:


C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\templates\form_macros.html:
{% macro render_field(field) %}
  <div class="form-group">
    <label for="{{ field.id }}">{{ field.label }}</label>
    {{ field(class="form-control") }}
  </div>
{% endmacro %}


C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\models.py:
from datetime import datetime
from flask_login import UserMixin
from itsdangerous import URLSafeTimedSerializer
import flask
from flask import current_app
import enum
from .extensions import bcrypt
import sqlalchemy
from app.database import db
from datetime import datetime, timedelta
from sqlalchemy.exc import SQLAlchemyError
from sqlalchemy_utils import ChoiceType
import json
from sqlalchemy import JSON, event
from sqlalchemy.sql import func
from sqlalchemy.ext.mutable import MutableList
import pytz


user_roles = db.Table('user_roles',
    db.Column('user_id', db.Integer, db.ForeignKey('user.id'), primary_key=True),
    db.Column('role_id', db.Integer, db.ForeignKey('role.id'), primary_key=True)
)

class User(UserMixin, db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True, nullable=False)
    password_hash = db.Column(db.String(128), nullable=False)
    email = db.Column(db.String(120), unique=True, nullable=False)
    confirmed = db.Column(db.Boolean, default=False)
    confirmed_on = db.Column(db.DateTime, nullable=True)
    reset_token = db.Column(db.String(120), nullable=True)
    roles = db.relationship('Role', secondary=user_roles, back_populates='users')
    phone = db.Column(db.String(20), nullable=True)
    date = db.Column(db.DateTime, default=datetime.utcnow)
    tos_accepted = db.Column(db.Boolean, default=False, nullable=False)
    first_name = db.Column(db.String(100), nullable=True)  # New field for first name
    last_name = db.Column(db.String(100), nullable=True)  # New field for last name

    def __init__(self, username, email, password):
        self.username = username
        self.email = email
        self.set_password(password)  # Use the method to hash the password

    def set_password(self, password):
        self.password_hash = bcrypt.generate_password_hash(password).decode('utf-8')

    def check_password(self, password):
        return bcrypt.check_password_hash(self.password_hash, password)

    def generate_reset_token(self, expiration=3600):
        s = URLSafeTimedSerializer(current_app.config['SECRET_KEY'])
        return s.dumps({'id': self.id}, salt='password-reset-salt')

    @staticmethod
    def confirm_reset_token(token, expiration=3600):
        s = URLSafeTimedSerializer(current_app.config['SECRET_KEY'])
        try:
            data = s.loads(token, salt='password-reset-salt', max_age=expiration)
        except:
            return None
        return User.query.get(data['id'])

    def has_role(self, role_name):
        return any(role.name == role_name for role in self.roles)

    def add_role(self, role):
        if not self.has_role(role.name):
            self.roles.append(role)

    def remove_role(self, role):
        if self.has_role(role.name):
            self.roles.remove(role)

    def __repr__(self):
        return f'<User username={self.username} email={self.email}>'
    
class Role(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(50), unique=True, nullable=False)
    users = db.relationship('User', secondary=user_roles, back_populates='roles')

    def __repr__(self):
        return f'<Role {self.name}>'

class Service(db.Model):
    __tablename__ = 'service'
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    description = db.Column(db.String(255))
    display_order = db.Column(db.Integer, default=0)

class Appointment(db.Model):
    __tablename__ = 'appointment'
    id = db.Column(db.Integer, primary_key=True)
    first_name = db.Column(db.String(100), nullable=False)
    last_name = db.Column(db.String(100), nullable=False)
    phone = db.Column(db.String(20), nullable=False)
    email = db.Column(db.String(100), nullable=False)
    preferred_date_time = db.Column(db.DateTime, nullable=False)  # Ensure this is stored as UTC
    service_id = db.Column(db.Integer, db.ForeignKey('service.id'), nullable=True)
    estimator_id = db.Column(db.Integer, db.ForeignKey('estimator.id'), nullable=False)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)  # UTC by default for created_at
    updated_at = db.Column(db.DateTime, onupdate=datetime.utcnow)  # UTC by default for updated_at

    # Relationships
    estimator = db.relationship('Estimator', backref=db.backref('appointments', lazy=True))
    service = db.relationship('Service', backref=db.backref('appointments', lazy=True))

    def to_dict(self):
        return {
            'id': self.id,
            'first_name': self.first_name,
            'last_name': self.last_name,
            'phone': self.phone,
            'email': self.email,
            'preferred_date_time': self.preferred_date_time.isoformat() if self.preferred_date_time else None,
            'service_id': self.service_id,
            'estimator_id': self.estimator_id,
            'created_at': self.created_at.isoformat() if self.created_at else None,
            'updated_at': self.updated_at.isoformat() if self.updated_at else None,
            'service': self.service.name if self.service else None,
            'estimator': self.estimator.name if self.estimator else None
        }

    # To ensure timestamps are always stored as UTC
    @staticmethod
    def to_utc(naive_datetime):
        """Converts a naive datetime to UTC"""
        return pytz.utc.localize(naive_datetime)

    @staticmethod
    def from_utc(utc_datetime):
        """Converts a UTC datetime to naive local time if needed"""
        return utc_datetime.astimezone(pytz.utc).replace(tzinfo=None)
    
@event.listens_for(Appointment, "before_insert")
def receive_before_insert(mapper, connection, target):
    # Make sure 'created_at' is always UTC
    target.created_at = datetime.utcnow()

@event.listens_for(Appointment, "before_update")
def receive_before_update(mapper, connection, target):
    # Make sure 'updated_at' is always UTC
    target.updated_at = datetime.utcnow()

class Estimator(db.Model):
    __tablename__ = 'estimator'
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)

class ContactFormSubmission(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    first_name = db.Column(db.String(100), nullable=False)
    last_name = db.Column(db.String(100), nullable=False)
    email = db.Column(db.String(120), nullable=False)
    phone = db.Column(db.String(20), nullable=False)
    message = db.Column(db.Text, nullable=False)
    submitted_at = db.Column(db.DateTime, default=datetime.utcnow)

C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\forms.py:
from flask_wtf import FlaskForm
import os
from flask import current_app
from wtforms import (StringField, PasswordField, SubmitField, BooleanField, IntegerField, SelectField, TextAreaField, DateField, DecimalField, FieldList, FormField,
                      FileField, FileField, FloatField, SelectMultipleField, HiddenField, ValidationError, EmailField, SubmitField, Form, FloatField, StringField )
from wtforms.fields import DateField, EmailField, TelField, DateTimeField
from wtforms.validators import DataRequired, Length, Email, EqualTo, ValidationError, Optional, NumberRange, Regexp, URL
from sqlalchemy import text
from flask_wtf import FlaskForm
from wtforms import StringField, PasswordField, BooleanField, SubmitField
from wtforms.validators import DataRequired, Email, Length, EqualTo
from app.models import Role, Service, Estimator

class RegistrationForm(FlaskForm):
    username = StringField('Username', validators=[DataRequired(), Length(min=3, max=100)])
    email = StringField('Email', validators=[DataRequired(), Email()])
    role = SelectField('Role', coerce=int, validators=[DataRequired()])
    password = PasswordField('Password', validators=[DataRequired(), Length(min=6, max=100)])
    confirm_password = PasswordField('Confirm Password', validators=[DataRequired(), EqualTo('password')])
    accept_tos = BooleanField('I accept the Terms and Conditions', validators=[DataRequired()])
    role = SelectField('Role', coerce=int, validators=[DataRequired()])
    submit = SubmitField('Sign Up')

    def __init__(self, *args, **kwargs):
        super(RegistrationForm, self).__init__(*args, **kwargs)
        self.role.choices = [(role.id, role.name) for role in Role.query.filter(Role.name != 'admin').all()]


class AcceptTOSForm(FlaskForm):
    accept_tos = BooleanField('I agree to the Terms and Conditions', validators=[DataRequired()])
    submit = SubmitField('Accept')

class ForgotPasswordForm(FlaskForm):
    email = StringField('Email', validators=[DataRequired(), Email()])
    submit = SubmitField('Request Password Reset')

class ResetPasswordForm(FlaskForm):
    password = PasswordField('New Password', validators=[DataRequired(), Length(min=6, max=100)])
    confirm_password = PasswordField('Confirm New Password', validators=[DataRequired(), EqualTo('password')])
    submit = SubmitField('Reset Password')

class LoginForm(FlaskForm):
    email = StringField('Email', validators=[DataRequired(), Email()])
    password = PasswordField('Password', validators=[DataRequired()])
    submit = SubmitField('Login')

class SettingsForm(FlaskForm):
    email = StringField('Email', validators=[DataRequired(), Email()])
    username = StringField('Username', validators=[DataRequired()])
    password = PasswordField('Password', validators=[DataRequired()])
    confirm_password = PasswordField('Confirm Password', validators=[EqualTo('password')])
    submit = SubmitField('Update Settings')

class ManageRolesForm(FlaskForm):
    def __init__(self, *args, **kwargs):
        super(ManageRolesForm, self).__init__(*args, **kwargs)
        self.roles.choices = [(role.id, role.name) for role in Role.query.all()]

    roles = SelectMultipleField(
        'Roles',
        coerce=int,  # Coerce form data to integer, as role IDs are integers
        validators=[DataRequired()]
    )
    submit = SubmitField('Update Roles')


class RoleSelectForm(Form):
    def __init__(self, *args, **kwargs):
        super(RoleSelectForm, self).__init__(*args, **kwargs)
        self.role.choices = [(role.id, role.name) for role in Role.query.all()]

class EditUserForm(FlaskForm):
    username = StringField('Username', validators=[DataRequired(), Length(min=2, max=50)])
    email = EmailField('Email', validators=[DataRequired(), Email()])
    is_active = BooleanField('Active User')

    submit = SubmitField('Update')

class EstimateRequestForm(FlaskForm):
    first_name = StringField('First Name', validators=[DataRequired(), Length(max=100)])
    last_name = StringField('Last Name', validators=[DataRequired(), Length(max=100)])
    phone = TelField('Phone Number', validators=[DataRequired()])
    email = EmailField('Email Address', validators=[DataRequired(), Email()])
    preferred_date = DateField('Preferred Date', format='%Y-%m-%d', validators=[DataRequired()])
    preferred_time = SelectField('Preferred Time', validators=[DataRequired()])
    estimator = SelectField('Select Estimator', coerce=int, validators=[DataRequired()])
    service = SelectField('Select Service', coerce=int, validators=[DataRequired()])  # Renamed from plan_option
    submit = SubmitField('Request Free Estimate')
    
    def __init__(self, *args, **kwargs):
        super(EstimateRequestForm, self).__init__(*args, **kwargs)
        self.service.choices = [(0, 'Please Select a Service')] + [(s.id, s.name) for s in Service.query.order_by('display_order').all()]  # Updated to Service
        self.estimator.choices = [(0, 'Please Select an Estimator')] + [(e.id, e.name) for e in Estimator.query.order_by('name').all()]
        self.preferred_time.choices = [(0, 'Please Select a Time')]

class EstimatorForm(FlaskForm):
    name = StringField('Name', validators=[DataRequired()])
    submit = SubmitField('Submit')

class ServiceOptionForm(FlaskForm):  
    name = StringField('Service Name', validators=[DataRequired()])  
    description = StringField('Service Description', validators=[Optional()])  
    display_order = IntegerField('Display Order', validators=[Optional(), NumberRange(min=0)])
    submit = SubmitField('Add Service')  

class ContactForm(FlaskForm):
    first_name = StringField('First Name', validators=[DataRequired(), Length(max=100)])
    last_name = StringField('Last Name', validators=[DataRequired(), Length(max=100)])
    email = StringField('Email', validators=[DataRequired(), Email(), Length(max=120)])
    phone = StringField('Phone Number', validators=[DataRequired(), Length(max=20)])
    message = TextAreaField('Message', validators=[DataRequired()])
    submit = SubmitField('Send Message')

class CSRFTokenForm(FlaskForm):
    csrf_token = HiddenField()

C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\static\js\slideout-menu.js:
document.addEventListener('DOMContentLoaded', function() {
    const menuIcon = document.getElementById('menu-icon');
    const slideoutMenu = document.getElementById('slideout-menu');
    const header = document.querySelector('.modern-header');

    // Toggle slideout menu
    menuIcon.addEventListener('click', function() {
        slideoutMenu.classList.toggle('active');
        menuIcon.classList.toggle('active'); // Rotate the hamburger icon
    });

    // Add 'scrolled' class to header on scroll
    window.addEventListener('scroll', function() {
        if (window.scrollY > 50) { // Adjust this value based on your header height
            header.classList.add('scrolled');
        } else {
            header.classList.remove('scrolled');
        }
    });
});

C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\templates\contact_confirmation.html:
{% extends "base.html" %}

{% block additional_css %}
<link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='css/cconfirm.css') }}">
{% endblock %}

{% block title %}
Contact Confirmation | Verso Industries
{% endblock %}

{% block head %}
<!-- Additional head content can go here -->
{% endblock %}

{% block content %}
<div class="section-spacer"></div>

<div class="container">
    <h1>Thank you for your message!</h1>
    <p>We have received your message and will get back to you shortly.</p>
    <p>You will be redirected to the homepage in 8 seconds.</p>
</div>

<div class="section-spacer"></div>

<!-- Meta refresh to redirect after 8 seconds -->
<meta http-equiv="refresh" content="8;url={{ url_for('main_routes.index') }}">
{% endblock %}


C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\static\js\scriptv.js:
// static/js/script.js
console.log('Script version 1.2.3 loaded');


C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\routes\__init__.py:


C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\LICENSE:
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.


C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\templates\contact.html:
{% extends "base.html" %}

{% block additional_css %}
<link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='css/contact.css') }}">
{% endblock %}

{% block title %}
Contact Us | Verso Industries
{% endblock %}

{% block head %}
<!-- Additional head content can go here -->
{% endblock %}

{% block content %}
<div class="section-spacer"></div>

<div class="contactus">
    <h1>Contact Us</h1>
    <form method="POST" action="{{ url_for('main_routes.contact') }}" onsubmit="return gtag_report_conversion('{{ url_for('main_routes.contact_confirmation') }}');">
        {{ form.hidden_tag() }}
        <div class="form-group">
            {{ form.first_name.label(class="form-label") }}
            {{ form.first_name(class="form-control", size=32) }}
            {% for error in form.first_name.errors %}
                <div class="text-danger">{{ error }}</div>
            {% endfor %}
        </div>
        <div class="form-group">
            {{ form.last_name.label(class="form-label") }}
            {{ form.last_name(class="form-control", size=32) }}
            {% for error in form.last_name.errors %}
                <div class="text-danger">{{ error }}</div>
            {% endfor %}
        </div>
        <div class="form-group">
            {{ form.email.label(class="form-label") }}
            {{ form.email(class="form-control", size=32) }}
            {% for error in form.email.errors %}
                <div class="text-danger">{{ error }}</div>
            {% endfor %}
        </div>
        <div class="form-group">
            {{ form.phone.label(class="form-label") }}
            {{ form.phone(class="form-control", size=32) }}
            {% for error in form.phone.errors %}
                <div class="text-danger">{{ error }}</div>
            {% endfor %}
        </div>
        <div class="form-group">
            {{ form.message.label(class="form-label") }}
            {{ form.message(class="form-control", rows=5, cols=40) }}
            {% for error in form.message.errors %}
                <div class="text-danger">{{ error }}</div>
            {% endfor %}
        </div>
        <div class="form-group">
            {{ form.submit(class="btn btn-primary") }}
        </div>
    </form>
</div>

<div class="section-spacer"></div>
{% endblock %}


C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\modules\locations.py:
def get_locations():
    # Define your locations as a list of dictionaries in Python
    locations = [
        {'lat': 43.6187, 'lng': -116.2146, 'title': 'Boise, Idaho'},
        {'lat': 43.6162, 'lng': -116.4415, 'title': 'Meridian, Idaho'},
        {'lat': 43.6918, 'lng': -116.4135, 'title': 'Eagle, Idaho'},
        {'lat': 43.7190, 'lng': -116.2686, 'title': 'Hidden Springs, Idaho'},
        {'lat': 43.4955, 'lng': -116.4576, 'title': 'Kuna, Idaho'},
        {'lat': 43.5861, 'lng': -116.6452, 'title': 'Nampa, Idaho'},
        {'lat': 43.6394, 'lng': -116.7355, 'title': 'Caldwell, Idaho'},
        {'lat': 43.7276, 'lng': -116.8092, 'title': 'Notus, Idaho'},
        {'lat': 43.7844, 'lng': -116.9614, 'title': 'Parma, Idaho'},
        {'lat': 43.6749, 'lng': -116.9142, 'title': 'Wilder, Idaho'},
        {'lat': 43.6175, 'lng': -116.9461, 'title': 'Homedale, Idaho'},
        {'lat': 43.5481, 'lng': -116.8143, 'title': 'Marsing, Idaho'},
        {'lat': 43.9696, 'lng': -116.8279, 'title': 'New Plymouth, Idaho'},
        {'lat': 44.0200, 'lng': -116.9410, 'title': 'Fruitland, Idaho'},
        {'lat': 44.0773, 'lng': -116.9471, 'title': 'Payette, Idaho'},
        {'lat': 44.2628, 'lng': -116.9887, 'title': 'Weiser, Idaho'},
        {'lat': 44.0313, 'lng': -116.9983, 'title': 'Ontario, Oregon'},
        {'lat': 43.7408, 'lng': -117.0757, 'title': 'Adrian, Oregon'},
        {'lat': 43.8819, 'lng': -117.0082, 'title': 'Nyssa, Oregon'},
        {'lat': 44.9002, 'lng': -116.1557, 'title': 'McCall, Idaho'},
        {'lat': 44.9701, 'lng': -116.2937, 'title': 'New Meadows, Idaho'},
        {'lat': 44.7287, 'lng': -116.0828, 'title': 'Donnelly, Idaho'},
        {'lat': 38.4765, 'lng': -119.6625, 'title': 'Nevada'},
        {'lat': 36.1251, 'lng': -115.3398, 'title': 'Las Vegas, Nevada'},
        {'lat': 45.3804, 'lng': -119.4239, 'title': 'Idaho'},
        {'lat': 44.1191, 'lng': -123.2225, 'title': 'Oregon'},
        {'lat': 39.4740, 'lng': -114.1867, 'title': 'Utah'}
    ]
    return locations

C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\templates\register.html:
{% extends "base.html" %}

{% block additional_css %}
    <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='css/register.css') }}">
{% endblock %}

{% block title %}
Register
{% endblock %}

{% block content %}
<!-- Flash Messages Display -->
{% with messages = get_flashed_messages(with_categories=true) %}
  {% if messages %}
    {% for category, message in messages %}
      <div class="alert alert-{{ category }} alert-dismissible fade show" role="alert">
        {{ message }}
        <button type="button" class="close" data-dismiss="alert" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
    {% endfor %}
  {% endif %}
{% endwith %}
<div class="login-container">
    <div class="login-box">
        <h2>Register</h2>
        <form action="{{ url_for('auth.register') }}" method="post" class="register-form">
            {{ form.hidden_tag() }}
            <div class="form-group">
                {{ form.username.label }}
                {{ form.username(class="form-control") }}
                {% if form.username.errors %}
                    <div class="alert alert-danger">
                        {{ form.username.errors[0] }}
                    </div>
                {% endif %}
            </div>
            <div class="form-group">
                {{ form.email.label }}
                {{ form.email(class="form-control") }}
                {% if form.email.errors %}
                    <div class="alert alert-danger">
                        {{ form.email.errors[0] }}
                    </div>
                {% endif %}
            </div>
            <div class="form-group">
                {{ form.password.label }}
                {{ form.password(class="form-control") }}
                {% if form.password.errors %}
                    <div class="alert alert-danger">
                        {{ form.password.errors[0] }}
                    </div>
                {% endif %}
            </div>
            <div class="form-group">
                {{ form.confirm_password.label }}
                {{ form.confirm_password(class="form-control") }}
                {% if form.confirm_password.errors %}
                    <div class="alert alert-danger">
                        {{ form.confirm_password.errors[0] }}
                    </div>
                {% endif %}
            </div>
            <div class="form-group">
                {{ form.role.label(class="form-control-label") }}
                {{ form.role(class="form-control") }}
                {% if form.role.errors %}
                    <div class="alert alert-danger">
                        {{ form.role.errors[0] }}
                    </div>
                {% endif %}
            </div>
            <div class="form-group">
                {{ form.accept_tos() }}
                <label for="accept_tos">I agree to the <a href="{{ url_for('main_routes.index') }}" target="_blank">Terms and Conditions</a></label>
                {% if form.accept_tos.errors %}
                    <div class="alert alert-danger">
                        {{ form.accept_tos.errors[0] }}
                    </div>
                {% endif %}
            </div>
            <div class="form-group">
                {{ form.submit(class="btn btn-primary") }}
            </div>
        </form>
    </div>
</div>
{% endblock %}


C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\directory_markdown.py:
import os
import concurrent.futures
import threading
import logging
import shutil

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def is_ignored_path(path, ignore_patterns):
    path_parts = path.split(os.sep)
    return any(part in ignore_patterns for part in path_parts)

def process_file(root, file, ignore_patterns, output_dir):
    if any(file.endswith(pattern) for pattern in ignore_patterns):
        return None

    file_path = os.path.join(root, file)
    relative_path = os.path.relpath(file_path, start=os.path.dirname(output_dir))
    markdown_file = os.path.join(output_dir, f"{relative_path}.md")
    os.makedirs(os.path.dirname(markdown_file), exist_ok=True)

    try:
        with open(file_path, 'rb') as content_file:  # Open as binary
            if is_binary(content_file.peek()):
                # Copy binary file directly to the output directory
                binary_output_path = os.path.join(output_dir, relative_path)
                os.makedirs(os.path.dirname(binary_output_path), exist_ok=True)
                shutil.copy(file_path, binary_output_path)
                logging.info(f"Copied binary file: {file_path}")
                return relative_path
            else:
                content_file.seek(0)  # Reset file pointer after peek
                content = content_file.read().decode('utf-8')
                with open(markdown_file, 'w', encoding='utf-8') as md_file:
                    md_file.write(f"# {relative_path}\n\n```\n{content}\n```\n")
                    return relative_path
    except Exception as e:
        logging.error(f"Error processing file {file_path}: {e}")
    return None

def is_binary(data):
    # A simple heuristic to check if a file is binary
    textchars = bytearray({7,8,9,10,12,13,27} | set(range(0x20, 0x100)) - {0x7f})
    return bool(data.translate(None, textchars))

def build_directory_contents(startpath, output_dir, ignore_patterns):
    num_workers = os.cpu_count() * 4

    # Ensure the output directory exists
    os.makedirs(output_dir, exist_ok=True)

    summary_file = os.path.join(output_dir, 'SUMMARY.md')
    contents = ["# Directory Summary\n\n"]

    with concurrent.futures.ThreadPoolExecutor(max_workers=num_workers) as executor:
        future_to_file = {
            executor.submit(process_file, root, file, ignore_patterns, output_dir): file
            for root, dirs, files in os.walk(startpath)
            for file in files if not is_ignored_path(root, ignore_patterns)
        }

        for future in concurrent.futures.as_completed(future_to_file):
            relative_path = future.result()
            if relative_path is not None:
                contents.append(f"- [{relative_path}]({relative_path}.md)\n")

    with open(summary_file, 'w', encoding='utf-8') as out:
        out.writelines(contents)

    logging.info(f"Directory summary has been written to {summary_file}")

# Replace 'your/code/repository/path' with the actual path to your code repository
code_repository_path = 'C:\\Users\\zimme\\Downloads\\agilesnipe-main\\agilesnipe-main'
output_dir = 'directory_structure'
ignore_patterns = ['venv', '__pycache__', 'instance', 'migrations', '.gitattributes', '.git', 'directory_ai.py', 'web_handlers.py', 'docs', 'run.py', 'dbc.py', 'tests', 'static']

build_directory_contents(code_repository_path, output_dir, ignore_patterns)


C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\__init__.py:
from flask import Flask, current_app, url_for
from flask_sqlalchemy import SQLAlchemy
from flask_login import LoginManager
from flask_wtf.csrf import CSRFProtect, generate_csrf
from flask_mail import Mail
from flask_bcrypt import Bcrypt
from flask_migrate import Migrate
from flask.cli import with_appcontext, AppGroup
from app.config import Config
from app.modules.role_setup import create_roles
from app.database import db
from app.models import User, Role
from dotenv import load_dotenv
import os
import logging
import click
import pytz
from datetime import datetime

# Load environment variables
load_dotenv()

# Initialize extensions
login_manager = LoginManager()
csrf = CSRFProtect()
mail = Mail()
bcrypt = Bcrypt()
migrate = Migrate()

# CLI group for debugging
debug_cli = AppGroup('debug')

@debug_cli.command('print-env')
def print_env():
    """Print environment variables for debugging."""
    print(f"FLASK_ENV: {os.environ.get('FLASK_ENV')}")
    print(f"SECRET_KEY: {os.environ.get('SECRET_KEY')}")
    print(f"DATABASE_URL: {current_app.config['SQLALCHEMY_DATABASE_URI']}")

# CLI command to create roles
@click.command('create-roles')
@with_appcontext
def create_roles_command():
    """Create default user roles."""
    create_roles()
    click.echo('Default roles have been created.')

# Application factory
def create_app(config_class=Config):
    app = Flask(__name__)

    # Configure logging
    logging.basicConfig(level=logging.DEBUG)
    app.logger.setLevel(logging.DEBUG)
    handler = logging.StreamHandler()
    handler.setLevel(logging.DEBUG)
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    handler.setFormatter(formatter)
    app.logger.addHandler(handler)

    # Load configuration
    app.config.from_object(config_class)
    app.config['SECRET_KEY'] = os.getenv('SECRET_KEY')
    app.config['SQLALCHEMY_DATABASE_URI'] = os.environ.get('DATABASE_URL', 'sqlite:///default.db').replace('postgres://', 'postgresql://', 1)
    app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
    app.config['SCHEDULER_API_ENABLED'] = True

    # Mail configuration from environment variables
    app.config['MAIL_SERVER'] = os.getenv('MAIL_SERVER', 'smtp.example.com')
    app.config['MAIL_PORT'] = int(os.getenv('MAIL_PORT', 587))
    app.config['MAIL_USE_TLS'] = os.getenv('MAIL_USE_TLS', 'True').lower() == 'true'
    app.config['MAIL_USERNAME'] = os.getenv('MAIL_USERNAME')
    app.config['MAIL_PASSWORD'] = os.getenv('MAIL_PASSWORD')
    app.config['MAIL_DEFAULT_SENDER'] = os.getenv('MAIL_DEFAULT_SENDER')

    # SQLAlchemy connection pooling options
    app.config['SQLALCHEMY_ENGINE_OPTIONS'] = {
        "pool_pre_ping": True,
        "pool_recycle": 300,
    }

    # Register CLI commands
    app.cli.add_command(create_roles_command)
    app.cli.add_command(debug_cli)

    # CLI command to set admin role
    @app.cli.command('set-admin')
    @click.argument('email')
    def set_admin(email):
        """Set a user as admin by email."""
        user = User.query.filter_by(email=email).first()
        if user:
            admin_role = Role.query.filter_by(name='admin').first()
            if admin_role not in user.roles:
                user.roles.append(admin_role)
                db.session.commit()
                print(f"User {email} set as admin.")
            else:
                print("User already has admin role.")
        else:
            print("User not found.")

    # Initialize extensions
    db.init_app(app)
    csrf.init_app(app)
    migrate.init_app(app, db)
    bcrypt.init_app(app)
    login_manager.login_view = 'auth.login'
    login_manager.init_app(app)
    mail.init_app(app)

    # User loader for Flask-Login
    @login_manager.user_loader
    def load_user(user_id):
        return User.query.get(int(user_id))

    # Inject CSRF token into templates
    @app.context_processor
    def inject_csrf_token():
        return dict(csrf_token=generate_csrf())

    # Override url_for to add version to static files
    @app.context_processor
    def override_url_for():
        return dict(url_for=dated_url_for)

    def dated_url_for(endpoint, **values):
        if endpoint == 'static':
            filename = values.get('filename')
            if filename:
                values['v'] = '1.0.0'  # Update this version manually as needed
        return url_for(endpoint, **values)

    # Register blueprints
    from app.routes.auth import auth
    from app.routes.main_routes import main
    from app.routes.user import user
    from app.routes.admin import admin as admin_blueprint
    from app.routes.blog import blog_blueprint, news_update, updates_blueprint

    app.register_blueprint(auth)
    app.register_blueprint(main)
    app.register_blueprint(user)
    app.register_blueprint(admin_blueprint, url_prefix='/admin')
    app.register_blueprint(blog_blueprint)
    app.register_blueprint(news_update)
    app.register_blueprint(updates_blueprint)

    return app

# Instantiate app for CLI and direct execution
app = create_app()

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=int(os.environ.get('PORT', 5000)))

C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\modules\file_manager.py:
# Standard library imports
import csv
import os

# Third-party imports
from flask import abort, g, make_response, send_file, current_user
from flask_login import login_required
import json

# Local application imports
from app.models import Campaign
import app

# For a given file, return whether it's an allowed type or not
def allowed_file(filename):
    return '.' in filename and \
           filename.rsplit('.', 1)[1] in app.config['ALLOWED_EXTENSIONS']

# Utility Functions
def load_json(file_path):
    with open(file_path, 'r') as f:
        return json.load(f)

# For a given file, return whether it's an allowed type or not
def allowed_file(filename):
    return '.' in filename and \
           filename.rsplit('.', 1)[1] in app.config['ALLOWED_EXTENSIONS']

@app.after_request
def delete_file(response):
    filename = getattr(g, 'filename', None)
    if filename:
        try:
            os.remove(filename)
        except Exception as error:
            app.logger.error("Error removing or closing downloaded file handle", error)
    return response
        

C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\.gitignore:
venv/
*.pyc
*.pyc
.pyc
*.psd
/instance
/migrations
/venv



C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\directory_ai.py:
import os
import concurrent.futures
import threading
import logging
from pathlib import Path
from typing import List, Optional, Set

# Configure logging for better debugging
logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

def is_ignored_path(path: str, ignore_dirs: Set[str], ignore_extensions: Set[str]) -> bool:
    """
    Check if a path should be ignored based on directory names or file extensions.
    
    Args:
        path: The file or directory path to check
        ignore_dirs: Set of directory names to ignore
        ignore_extensions: Set of file extensions to ignore (including dot, e.g., '.txt')
    
    Returns:
        bool: True if the path should be ignored
    """
    path_obj = Path(path)
    
    # Check if any directory in the path matches ignore_dirs
    if any(part in ignore_dirs for part in path_obj.parts):
        logger.debug(f"Ignoring path {path} due to directory match")
        return True
    
    # Check file extension
    if path_obj.suffix.lower() in ignore_extensions:
        logger.debug(f"Ignoring path {path} due to extension {path_obj.suffix}")
        return True
    
    logger.debug(f"Path {path} is not ignored")
    return False

def process_file(root: str, file: str, ignore_dirs: Set[str], ignore_extensions: Set[str]) -> Optional[List[str]]:
    """
    Process a single file and return its contents with metadata.
    
    Args:
        root: Directory path containing the file
        file: Name of the file to process
        ignore_dirs: Set of directories to ignore
        ignore_extensions: Set of file extensions to ignore
    
    Returns:
        Optional[List[str]]: File contents with metadata or None if ignored
    """
    file_path = os.path.join(root, file)
    
    if is_ignored_path(file_path, ignore_dirs, ignore_extensions):
        logger.debug(f"Skipping ignored file: {file_path}")
        return None

    content_lines = [f"{file_path}:\n"]
    logger.debug(f"Processing file: {file_path}")
    try:
        # Only process text files smaller than 10MB
        if os.path.getsize(file_path) > 10 * 1024 * 1024:
            content_lines.append("<File too large to process>\n")
            logger.debug(f"File too large: {file_path}")
            return content_lines
            
        with open(file_path, 'r', encoding='utf-8', errors='ignore') as content_file:
            content = content_file.read()
            content_lines.append(content)
            logger.debug(f"Successfully read file: {file_path}")
    except UnicodeDecodeError:
        content_lines.append("<Binary file or unsupported encoding>\n")
        logger.debug(f"Binary or unsupported encoding: {file_path}")
    except PermissionError:
        content_lines.append("<Permission denied>\n")
        logger.debug(f"Permission denied: {file_path}")
    except Exception as e:
        logger.error(f"Error processing {file_path}: {str(e)}")
        content_lines.append(f"<Error reading file: {e}>\n")
    
    content_lines.append("\n\n")
    return content_lines

def build_directory_contents(startpath: str, output_file: str, 
                           ignore_dirs: Set[str], ignore_extensions: Set[str]) -> None:
    """
    Build directory contents and write to output file using concurrent processing.
    
    Args:
        startpath: Root directory to start scanning
        output_file: Output file path
        ignore_dirs: Set of directories to ignore
        ignore_extensions: Set of file extensions to ignore
    """
    # Validate input path
    start_path = Path(startpath)
    if not start_path.exists() or not start_path.is_dir():
        raise ValueError(f"Invalid or non-existent directory: {startpath}")
    
    # Validate output file path
    output_path = Path(output_file)
    try:
        output_path.parent.mkdir(parents=True, exist_ok=True)
    except Exception as e:
        raise ValueError(f"Cannot create output directory: {str(e)}")

    # Use a lock for thread-safe list operations
    contents_lock = threading.Lock()
    contents: List[str] = []
    
    # Optimize number of workers based on CPU count
    num_workers = max(1, min(os.cpu_count() * 2, 32))  # Cap at 32 to prevent resource exhaustion
    
    logger.info(f"Starting directory scan with {num_workers} workers")
    
    with concurrent.futures.ThreadPoolExecutor(max_workers=num_workers) as executor:
        future_to_file = {}
        for root, dirs, files in os.walk(startpath, topdown=True):
            # Log directories being scanned
            logger.debug(f"Scanning directory: {root}")
            # Modify dirs in-place to skip ignored directories
            dirs[:] = [d for d in dirs if d not in ignore_dirs]
            logger.debug(f"Directories after filtering: {dirs}")
            for file in files:
                future_to_file[executor.submit(process_file, root, file, ignore_dirs, ignore_extensions)] = file
        
        for future in concurrent.futures.as_completed(future_to_file):
            try:
                file_content = future.result()
                if file_content:
                    with contents_lock:
                        contents.extend(file_content)
                        logger.debug(f"Added content from file, current content length: {len(contents)}")
            except Exception as e:
                logger.error(f"Error processing future: {str(e)}")

    # Log contents before writing
    logger.debug(f"Total content lines to write: {len(contents)}")
    
    # Write results to output file
    try:
        with open(output_file, 'w', encoding='utf-8') as out:
            out.writelines(contents)
        logger.info(f"Successfully wrote contents to {output_file}")
    except Exception as e:
        logger.error(f"Error writing to output file: {str(e)}")
        raise

def main():
    """Main function to execute the directory contents builder."""
    code_repository_path = 'C:\\Users\\zimme\\OneDrive\\Documents\\GitHub\\flask-template-repo'
    output_file = 'output_main.txt'
    
    # Separate directory names and file extensions
    ignore_dirs = {
        'env', 'images', 'fonts', 'docs', '__pycache__', 'instance', 
        'tests', 'migrations', 'flask_stripe', '.git', 'fullcalendar',
    }
    ignore_extensions = {
        '.txt', '.css', '.gitattributes', '.md', '.pyc'
    }
    
    try:
        build_directory_contents(code_repository_path, output_file, ignore_dirs, ignore_extensions)
        print(f"Directory contents have been written to {output_file}")
    except Exception as e:
        logger.error(f"Failed to build directory contents: {str(e)}")
        print(f"Error: {str(e)}")

if __name__ == '__main__':
    main()

C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\static\js\calendar.js:
document.addEventListener('DOMContentLoaded', function() {
    console.log('DOMContentLoaded event fired.');

    var calendarEl = document.getElementById('calendar');
    console.log('Calendar element:', calendarEl);
    
    var calendarContainer = document.getElementById('calendar-container');
    console.log('Calendar container element:', calendarContainer);
    
    var step1 = document.getElementById('step-1');
    console.log('Step 1 element:', step1);
    
    var step2 = document.getElementById('step-2');
    console.log('Step 2 element:', step2);
    
    var nextButton = document.getElementById('next-button');
    console.log('Next button element:', nextButton);
    
    var userTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
    console.log('User Timezone detected:', userTimezone);
    
    var csrfToken = getCsrfToken();
    console.log('CSRF Token fetched:', csrfToken);
    
    let calendar; // Declare calendar variable to be accessible throughout

    if (typeof FullCalendar !== 'undefined') {
        try {
            // Initialize the calendar
            calendar = new FullCalendar.Calendar(calendarEl, {
                initialView: 'dayGridMonth',
                selectable: true, // Enable date selection
                headerToolbar: {
                    left: 'prev,next today',
                    center: 'title',
                    right: 'dayGridMonth,listMonth'
                },
                events: '/api/upcoming_appointments',
                eventColor: '#378006',
                timeZone: 'local',  // Ensure FullCalendar uses the local time zone

                select: function(info) {
                    console.log('Date selected:', info.startStr);

                    // Highlight the selected date
                    highlightDate(info.startStr);

                    // Handle date selection
                    handleDateSelection(info.startStr);
                },

                dateClick: function(info) {
                    console.log('Date clicked:', info.dateStr);

                    // Highlight the clicked date
                    highlightDate(info.dateStr);

                    // Handle date click
                    handleDateSelection(info.dateStr);
                }
            });

            console.log('Calendar initialized successfully.');

            // Render the calendar
            calendar.render();
            console.log('Calendar rendered.');
        } catch (error) {
            console.error('Error initializing or rendering FullCalendar:', error);
        }
    } else {
        console.error('FullCalendar is not defined.');
    }

    // Add touch event listener for date selection on touch devices
    calendarEl.addEventListener('touchstart', function(event) {
        console.log('Touchstart event detected:', event);
        var touch = event.touches[0];
        var targetElement = document.elementFromPoint(touch.clientX, touch.clientY);
        console.log('Touch event detected on element:', targetElement);
        if (targetElement && targetElement.hasAttribute('data-date')) {
            var dateStr = targetElement.getAttribute('data-date');
            console.log('Date string from touch event:', dateStr);
            if (dateStr) {
                highlightDate(dateStr);
                handleDateSelection(dateStr);
            }
        }
    });

    // Add event listener to the date input field
    addDateInputListener();

    function addDateInputListener() {
        var dateInput = document.getElementById('preferred_date');
        dateInput.addEventListener('change', function() {
            var selectedDate = this.value;
            if (selectedDate) {
                handleDateInputChange(selectedDate);
            }
        });
    }

    function handleDateInputChange(dateStr) {
        console.log('Date input changed:', dateStr);

        // Select the date in the calendar
        var date = new Date(dateStr + 'T00:00:00'); // Ensure time component is set to midnight
        calendar.select(date);

        // Highlight the date
        highlightDate(dateStr);

        // Fetch available time slots
        handleDateSelection(dateStr);
    }

    function highlightDate(dateStr) {
        // Remove highlight from previously selected date
        document.querySelectorAll('.selected-date').forEach(function(cell) {
            cell.classList.remove('selected-date');
        });

        // Add highlight to the selected date
        var selectedCell = document.querySelector('[data-date="' + dateStr + '"]');
        if (selectedCell) {
            selectedCell.classList.add('selected-date');
        }
    }

    function handleDateSelection(dateStr) {
        console.log('Handling date selection:', dateStr);

        document.getElementById('preferred_date').value = dateStr;
        console.log('Preferred date set to:', dateStr);

        fetch('/get_available_time_slots', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrfToken
            },
            body: JSON.stringify({
                date: dateStr,
                timezone: userTimezone
            })
        })
        .then(response => {
            console.log('Fetch response:', response);
            if (!response.ok) {
                throw new Error('Network response was not ok');
            }
            return response.json();
        })
        .then(data => {
            console.log('Time slots data received:', data);
            populateTimeSlots(data, userTimezone);
        })
        .catch(error => {
            console.error('Error fetching time slots:', error);
        });
    }

    nextButton.addEventListener('click', handleNextButtonClick);
    nextButton.addEventListener('touchstart', handleNextButtonClick);

    function handleNextButtonClick(event) {
        event.preventDefault();
        console.log('"Next" button clicked.');

        var form = document.getElementById('personal-info-form');
        console.log('Personal info form element:', form);

        if (form.checkValidity()) {
            console.log('Personal info form validation successful.');

            copyPersonalInfoToStep2();

            step1.style.display = 'none';
            step2.style.display = 'block';
            calendarContainer.style.display = 'block';
            console.log('Navigating to Step 2 and showing the calendar.');

            // Force a reflow and repaint of the calendar container
            calendarContainer.offsetHeight;

            // Re-render the calendar to ensure it displays correctly
            calendar.render();
        } else {
            console.warn('Personal info form validation failed.');
            form.reportValidity();
        }
    }
});

function copyPersonalInfoToStep2() {
    var form = document.getElementById('personal-info-form');
    console.log('Copying personal info from form:', form);

    document.getElementById('hidden_first_name').value = form.querySelector('[name="first_name"]').value;
    document.getElementById('hidden_last_name').value = form.querySelector('[name="last_name"]').value;
    document.getElementById('hidden_phone').value = form.querySelector('[name="phone"]').value;
    document.getElementById('hidden_email').value = form.querySelector('[name="email"]').value;
    console.log('Personal info copied to Step 2.');
}

function convertUTCToLocal(utcTimeStr, userTimezone) {
    console.log('Converting UTC time to local time:', utcTimeStr, 'for timezone:', userTimezone);
    const utcDateTime = new Date(utcTimeStr);

    if (isNaN(utcDateTime)) {
        console.error('Invalid UTC Date string:', utcTimeStr);
        return 'Invalid Date';
    }

    const localTimeFormatter = new Intl.DateTimeFormat('en-US', {
        timeZone: userTimezone,
        hour: '2-digit',
        minute: '2-digit',
        hour12: true
    });

    const localTime = localTimeFormatter.format(utcDateTime);
    console.log('Converted UTC to local time:', utcTimeStr, '->', localTime);
    return localTime;
}

function populateTimeSlots(data, userTimezone) {
    console.log('Populating time slots with data:', data, 'and timezone:', userTimezone);
    const timeDropdown = document.getElementById('preferred_time');
    timeDropdown.innerHTML = '';

    if (data.timeSlots.length === 0) {
        const option = document.createElement('option');
        option.textContent = 'No available slots';
        option.disabled = true;
        timeDropdown.appendChild(option);
        console.warn('No available time slots for the selected date.');
    } else {
        data.timeSlots.forEach(slot => {
            const localTime = convertUTCToLocal(slot, userTimezone);
            const option = document.createElement('option');
            option.value = slot;
            option.textContent = localTime;
            timeDropdown.appendChild(option);
        });
        console.log('Time slots populated in dropdown.');
    }
}

C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\templates\confirmation.html:
{% extends 'base.html' %}

{% block content %}
<div class="container">
    <h1>Booking Confirmation</h1>
    <div class="confirmation-details">
        <h2>Booking Details</h2>
        <p><strong>Booking ID:</strong> {{ booking.id }}</p>
        <p><strong>Dumpster Size:</strong> {{ booking.dumpster.size }}</p>
        <p><strong>Start Date:</strong> {{ booking.start_date | dateformat }}</p>
        <p><strong>End Date:</strong> {{ booking.end_date | dateformat }}</p>
        <p><strong>Total Price:</strong> {{ booking.total_price | currencyformat }}</p>

        <h2>Payment Confirmation</h2>
        <p><strong>Payment Status:</strong> {{ payment_status }}</p>
        {% if payment_status == 'succeeded' %}
        <p>Your payment has been processed successfully.</p>
        {% else %}
        <p>There was an issue with your payment. Please contact support.</p>
        {% endif %}
    </div>
    <a href="{{ url_for('main_routes.index') }}" class="btn btn-primary">Return to Home</a>
</div>
{% endblock %}


C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\.slugignore:
# Ignore virtual environment directory
venv/

# Ignore Python bytecode files
*.pyc

# Ignore Photoshop files
*.psd

# Ignore instance directory
/instance

# Ignore migrations directory
/migrations

# Ignore virtual environment directory (redundant entry removed)
/venv


C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\templates\services.html:
{% extends 'base.html' %}

{% block additional_css %}
<link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='css/about.css') }}">
{% endblock %}

{% block content %}

{% endblock %}


C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\modules\role_setup.py:
# ideal-sniffle/app/modules/role_setup.py

from app.models import Role
from app.database import db

def create_roles():
    """Create default roles."""
    roles = ['admin', 'user', 'commercial']  # Add other roles as needed
    for name in roles:
        if not Role.query.filter_by(name=name).first():
            new_role = Role(name=name)
            db.session.add(new_role)
    db.session.commit()



C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\routes\auth.py:
from flask import Blueprint, render_template, redirect, url_for, flash, request, session
from flask_login import login_user, logout_user
from flask_mail import Message
from flask import current_app as app
# Assuming the below modules are part of your application
from app import db, mail, bcrypt  # Adjust 'yourapp' to your actual app's name
from app.models import User, Role  # Adjust 'yourapp.models' to your actual models' location
from app.forms import RegistrationForm, LoginForm, EstimateRequestForm  # Adjust 'yourapp.forms' to your actual forms' location

auth = Blueprint('auth', __name__)

@auth.context_processor
def combined_context_processor():
    erf_form = EstimateRequestForm()
    return dict(erf_form=erf_form)

@auth.route("/register", methods=['GET', 'POST'])
def register():
    form = RegistrationForm()
    form.role.choices = [(role.id, role.name) for role in Role.query.filter(Role.name != 'admin').all()]

    if form.validate_on_submit():
        if not form.accept_tos.data:
            flash('You must agree to the Terms and Conditions to register.', 'warning')
            return render_template('register.html', title='Register', form=form)

        # Refactor user existence checks into a function
        if user_exists(form.email.data, form.username.data):
            return render_template('register.html', title='Register', form=form)

        # Create and add the new user
        new_user = create_new_user(form)
        db.session.add(new_user)
        db.session.commit()
        login_user(new_user)

        # Handle post-registration redirection
        return handle_post_registration_redirect()

    return render_template('register.html', title='Register', form=form)

def user_exists(email, username):
    """Check if a user with the given email or username already exists."""
    if User.query.filter_by(email=email).first():
        flash('An account with this email already exists.', 'warning')
        return True
    if User.query.filter_by(username=username).first():
        flash('This username is already taken. Please choose a different one.', 'warning')
        return True
    return False

def create_new_user(form):
    """Create a new user instance from the registration form."""
    new_user = User(username=form.username.data, email=form.email.data, password=form.password.data)
    role = Role.query.get(form.role.data)
    if role:
        new_user.roles.append(role)
    return new_user


def handle_post_registration_redirect():
    """Handle redirection after successful registration."""
    if 'booking_address' in session:
        flash('Account created! Please continue with your booking.', 'success')
        return redirect(url_for('user.manage_booking'))
    else:
        flash('Your account has been created! You are now logged in.', 'success')
        return redirect(url_for('main_routes.index'))

@auth.route("/login", methods=['GET', 'POST'])
def login():
    form = LoginForm()
    if form.validate_on_submit():
        # Normalize email to lowercase
        email = form.email.data.lower()
        user = User.query.filter_by(email=email).first()

        if user:
            if bcrypt.check_password_hash(user.password_hash, form.password.data):
                login_user(user)
                app.logger.info(f'User logged in: {user.username}')  # Logging successful login
                
                if not user.tos_accepted:
                    # Redirect to accept terms if not already accepted
                    return redirect(url_for('main_routes.accept_terms'))
                
                flash('You have been logged in!', 'success')
                next_page = request.args.get('next')
                return redirect(next_page) if next_page else redirect(url_for('main_routes.index'))
            else:
                # Log failed password check
                app.logger.warning(f'Failed login attempt for {email}: Incorrect password')
        else:
            # Log failed login attempt due to user not found
            app.logger.warning(f'Failed login attempt for {email}: User not found')

        flash('Login Unsuccessful. Please check email and password', 'danger')

    # Log form validation errors
    if form.errors:
        app.logger.warning(f'Login form validation errors: {form.errors}')

    return render_template('login.html', title='Login', form=form)

@auth.route("/logout")
def logout():
    # Clear the entire session when the user logs out
    session.clear()
    logout_user()
    return redirect(url_for('auth.login'))

@auth.route('/forgot_password', methods=['POST'])
def forgot_password():
    email = request.form.get('email')
    user = User.query.filter_by(email=email).first()
    if user:
        token = user.generate_reset_token()
        msg = Message("Password reset request",
                      sender="noreply@demo.com",
                      recipients=[user.email])
        msg.body = f"""To reset your password, visit the following link:
{url_for('main.reset_password', token=token, _external=True)}

If you did not make this request then simply ignore this email and no changes will be made.
"""
        mail.send(msg)
        return "Password reset email sent!"
    else:
        return "Invalid email"

@auth.route('/reset_password', methods=['POST'])
def reset_password():
    token = request.form.get('token')
    password = request.form.get('password')
    user = User.verify_reset_token(token)
    if user:
        # Hash the new password with bcrypt
        hashed_password = bcrypt.generate_password_hash(password).decode('utf-8')
        user.set_password(hashed_password)  # Assuming set_password is properly adjusted to use bcrypt
        db.session.commit()
        flash('Your password has been updated!', 'success')
        return redirect(url_for('auth.login'))
    else:
        flash('That is an invalid or expired token', 'warning')
        return redirect(url_for('main.register'))


C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\templates\admin\content_management.html:
{% extends "base.html" %}

{% block title %}Content Management{% endblock %}

{% block content %}
<div class="content-management">
    <h2>Content Management</h2>

    <!-- Form for Adding or Editing Content -->
    <form action="{{ url_for('admin.content_management') }}" method="post">
        {{ form.hidden_tag() }}
        <div>
            <label for="title">Title:</label>
            {{ form.title(class="form-control") }}
            {% if form.title.errors %}
                <div class="error">{{ form.title.errors[0] }}</div>
            {% endif %}
        </div>
        <div>
            <label for="content">Content:</label>
            {{ form.content(class="form-control") }}
            {% if form.content.errors %}
                <div class="error">{{ form.content.errors[0] }}</div>
            {% endif %}
        </div>
        <div>
            {{ form.submit(class="btn btn-primary") }}
        </div>
    </form>

    <!-- List Existing Content -->
    <div class="existing-content">
        <h3>Existing Announcements</h3>
        {% for announcement in announcements %}
        <div class="announcement-item">
            <h4>{{ announcement.title }}</h4>
            <p>{{ announcement.content }}</p>
            <div class="actions">
                <a href="{{ url_for('admin.edit_content', id=announcement.id) }}" class="btn btn-secondary">Edit</a>
                <a href="{{ url_for('admin.delete_content', id=announcement.id) }}" class="btn btn-danger">Delete</a>
            </div>
        </div>
        {% else %}
        <p>No announcements to display.</p>
        {% endfor %}
    </div>
</div>
{% endblock %}


C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\templates\admin\dashboard.html:
{% extends "base.html" %}

{% block additional_css %}
<link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='css/admindash.css') }}">
{% endblock %}

{% block scripts %}
<script>
    function confirmDeletion() {
        return confirm('Are you sure you want to delete this item?');
    }

    document.addEventListener('DOMContentLoaded', function() {
        const csrfToken = document.querySelector('meta[name="csrf-token"]').getAttribute('content');
        document.querySelectorAll('form').forEach(form => {
            const hiddenInput = document.createElement('input');
            hiddenInput.type = 'hidden';
            hiddenInput.name = 'csrf_token';
            hiddenInput.value = csrfToken;
            form.appendChild(hiddenInput);
        });
    });
</script>
{% endblock %}

{% block content %}
<div class="admin-dashboard">
    <h1>Admin Dashboard</h1>

    <!-- Dashboard Statistics -->
    <div class="dashboard-stats">
        <p>Total users: {{ total_users }}</p>
    </div>

    <!-- Upcoming Appointments Section -->
    <div class="appointments-section">
        <h2>Upcoming Appointments</h2>
        <div class="appointments-container">
            {% for appointment in appointments %}
            <div class="appointment-card">
                <p><strong>Name:</strong> {{ appointment.first_name }} {{ appointment.last_name }}</p>
                <p><strong>Email:</strong> {{ appointment.email }}</p>
                <p><strong>Phone:</strong> {{ appointment.phone }}</p>
                <p><strong>Preferred Date and Time:</strong>
                    {{ appointment.local_time.strftime('%Y-%m-%d %I:%M %p') }} (America/Denver)
                </p>
                <p><strong>Estimator:</strong> {{ appointment.estimator.name }}</p>
                <p><strong>Service:</strong> {{ appointment.service.name }}</p>
                <form action="{{ url_for('admin.delete_appointment', appointment_id=appointment.id) }}" method="post" onsubmit="return confirm('Are you sure you want to delete this appointment?');">
                    {{ form.csrf_token }}
                    <button type="submit" class="danger-btn">Delete</button>
                </form>
            </div>
            {% endfor %}
        </div>
    </div>

    <!-- Spacer -->
    <div class="spacer"></div>

    <!-- Contact Form Submissions Section -->
    <div class="submissions-section">
        <h3>Contact Form Submissions</h3>
        <div class="submissions-container">
            {% for submission in contact_form_submissions %}
            <div class="submission-card">
                <p><strong>First Name:</strong> {{ submission.first_name }}</p>
                <p><strong>Last Name:</strong> {{ submission.last_name }}</p>
                <p><strong>Email:</strong> {{ submission.email }}</p>
                <p><strong>Phone:</strong> {{ submission.phone }}</p>
                <p><strong>Message:</strong> {{ submission.message }}</p>
                <p><strong>Submitted At:</strong> {{ submission.submitted_at.strftime('%Y-%m-%d %H:%M:%S') }}</p>
                <form action="{{ url_for('admin.delete_contact_submission', id=submission.id) }}" method="post" onsubmit="return confirm('Are you sure you want to delete this submission?');">
                    <button type="submit" class="danger-btn">Delete</button>
                </form>
            </div>
            {% endfor %}
        </div>
    </div>

    <!-- Spacer -->
    <div class="spacer"></div>

    <!-- Admin Pages Links -->
    <div class="admin-links">
        <h2>Admin Pages</h2>
        <ul class="admin-pages-list">
            <li><a href="{{ url_for('admin.admin_estimator') }}">Estimator Management</a></li>
            <li><a href="{{ url_for('admin.services') }}">Service Management</a></li>
            <li><a href="{{ url_for('admin.generate_sitemap_route') }}">Generate Sitemap</a></li>
            <li><a href="{{ url_for('admin.user_management') }}">User Management</a></li>
        </ul>
    </div>
</div>
{% endblock %}

C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\templates\admin\edit_user.html:
<!-- admin/edit_user.html -->
{% extends "base.html" %}
{% block content %}
    <h2>Edit User</h2>
    <form method="post">
        {{ form.hidden_tag() }}
        <p>
            {{ form.username.label }}<br>
            {{ form.username(size=32) }}
        </p>
        <p>
            {{ form.email.label }}<br>
            {{ form.email(size=32) }}
        </p>
        <!-- Include other fields as necessary -->
        <p><input type="submit" value="Update"></p>
    </form>
{% endblock %}


C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\templates\admin\estimator_form.html:
<!-- templates/admin/estimator_form.html -->

{% extends "base.html" %}

{% block additional_css %}
<link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='css/estimator.css') }}">
{% endblock %}

{% block title %}Add Estimator{% endblock %}

{% block content %}
<div class="container">
    <h2>Add New Estimator</h2>
    <form action="{{ url_for('admin.admin_estimator') }}" method="post" enctype="multipart/form-data">
        {{ form.hidden_tag() }}
        
        <div class="form-group">
            {{ form.name.label(class="form-control-label") }}
            {{ form.name(class="form-control") }}
            {% if form.name.errors %}
                <div class="alert alert-danger" role="alert">
                    {% for error in form.name.errors %}
                        <p>{{ error }}</p>
                    {% endfor %}
                </div>
            {% endif %}
        </div>
        
        <div class="form-group">
            {{ form.submit(class="btn btn-primary") }}
        </div>
    </form>
</div>
{% endblock %}


C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\templates\admin\floorplan.html:
{% extends "base.html" %}

{% block additional_css %}
<link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='css/services.css') }}">
{% endblock %}

{% block content %}
<h2>Add Plan Option</h2>
<form method="POST">
    {{ form.hidden_tag() }}
    <div>
        {{ form.name.label }} {{ form.name() }}
        {% if form.name.errors %}
            <div style="color: red;">{{ form.name.errors[0] }}</div>
        {% endif %}
    </div>
    <div>
        {{ form.description.label }} {{ form.description() }}
        {% if form.description.errors %}
            <div style="color: red;">{{ form.description.errors[0] }}</div>
        {% endif %}
    </div>
    <div>
        {{ form.display_order.label }} {{ form.display_order() }}
        {% if form.display_order.errors %}
            <div style="color: red;">{{ form.display_order.errors[0] }}</div>
        {% endif %}
    </div>
    <div>
        {{ form.submit() }}
    </div>
</form>

<h2>Existing Plan Options</h2>
<ul>
    {% for plan_option in plan_options %}
        <li>{{ plan_option.name }} - Order: {{ plan_option.display_order }}</li>
    {% endfor %}
</ul>    
{% endblock %}


C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\templates\admin\manage_subscriptions.html:
{% extends "base.html" %}
{% block content %}
  <h2>Manage User Subscriptions</h2>
  <form method="POST">
    {{ form.hidden_tag() }}
    <div>
      {{ form.user_email.label }}<br>
      {{ form.user_email(size=30) }}
      {% for error in form.user_email.errors %}
        <span style="color: red;">[{{ error }}]</span>
      {% endfor %}
    </div>
    <div>
      {{ form.subscription_tier.label }}<br>
      {{ form.subscription_tier() }}
    </div>
    <div>
      {{ form.submit() }}
    </div>
  </form>
{% endblock %}


C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\templates\admin\system_settings.html:
{% extends "base.html" %}

{% block content %}
<div class="system-settings">
    <h2>System Settings</h2>
    <form method="POST">
        <!-- Implement form fields for various settings -->

        <button type="submit">Save Changes</button>
    </form>
</div>
{% endblock %}


C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\templates\admin\roles.html:
{% extends "base.html" %}

{% block content %}
<h2>Manage Roles for {{ user.username }}</h2>
<form method="post">
    {{ form.hidden_tag() }}
    <div>
        {{ form.roles.label }}
        {{ form.roles(size=10, multiple=true) }}  <!-- Adjust size and style as needed -->
        {% for error in form.roles.errors %}
            <span style="color: red;">{{ error }}</span>
        {% endfor %}
    </div>
    <div>
        {{ form.submit() }}
    </div>
</form>
{% endblock %}

C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\templates\admin\user_management.html:
{% extends "base.html" %}

{% block content %}
<div class="user-management">
    <h2>User Management</h2>
    <table>
        <thead>
            <tr>
                <th>Username</th>
                <th>Email</th>
                <th>Role</th>
                <th>Actions</th>
            </tr>
        </thead>
        <tbody>
            {% for user in users %}
            <tr>
                <td>{{ user.username }}</td>
                <td>{{ user.email }}</td>
                <td>{{ 'Agency' if user.is_agency else 'User' }}</td>
                <td>
                    <a href="{{ url_for('admin.edit_user', id=user.id) }}">Edit</a> |
                    <a href="{{ url_for('delete_user', id=user.id) }}">Delete</a> |
                    <a href="{{ url_for('view_user', id=user.id) }}">View</a>
                </td>
            </tr>
            {% endfor %}
        </tbody>
    </table>
</div>
{% endblock %}


C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\templates\admin\verifications.html:
{% extends "base.html" %}

{% block title %}Admin Verification Dashboard{% endblock %}

{% block content %}
<div class="admin-verification-dashboard">
    <h2>Agency Verification Dashboard</h2>
    <div class="agency-list">
        {% for agency in unverified_agencies %}
            <div class="agency-item">
                <h3>{{ agency.agency_name }}</h3>
                <p><strong>License File:</strong> 
                    <a href="{{ url_for('static', filename='path/to/licenses/' + agency.business_license_path) }}" target="_blank">View License</a>
                </p>
                <form action="{{ url_for('verify_business_license', user_id=agency.id) }}" method="POST" class="verify-form">
                    <button type="submit" class="verify-button">Verify Agency</button>
                </form>
            </div>
        {% else %}
            <p>No agencies awaiting verification.</p>
        {% endfor %}
    </div>
</div>
{% endblock %}

{% block scripts %}
    <script src="{{ url_for('static', filename='js/admin_verifications.js') }}"></script>
{% endblock %}


C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\templates\UserDashboard\commercial_dashboard.html:
{% extends "base.html" %}

{% block additional_css %}
<link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='css/cdash.css') }}">
{% endblock %}

{% block content %}


{% endblock content %}

{% block scripts %}


{% endblock scripts %}


C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\templates\UserDashboard\user_dashboard.html:
{% extends "base.html" %}

{% block additional_css %}
<link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='css/cdash.css') }}">
{% endblock %}

{% block content %}
<!-- Spacer to ensure content doesn't hide behind the fixed header -->
<div class="section-spacer"></div>


<div class="section-spacer"></div>
{% endblock content %}

{% block scripts %}
<!-- Include any JavaScript files here -->
{% endblock scripts %}


