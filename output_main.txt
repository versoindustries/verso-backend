C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\static\js\calendar.js:
// app/static/js/calendar.js
document.addEventListener('DOMContentLoaded', function() {
    console.debug('DOMContentLoaded event fired.');

    const calendarEl = document.getElementById('calendar');
    console.debug('Calendar element:', calendarEl);
    
    const calendarContainer = document.getElementById('calendar-container');
    console.debug('Calendar container element:', calendarContainer);
    
    const step1 = document.getElementById('step-1');
    console.debug('Step 1 element:', step1);
    
    const step2 = document.getElementById('step-2');
    console.debug('Step 2 element:', step2);
    
    const nextButton = document.getElementById('next-button');
    console.debug('Next button element:', nextButton);
    
    const userTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
    console.debug('User Timezone detected:', userTimezone);
    
    const csrfToken = getCsrfToken();
    console.debug('CSRF Token fetched:', csrfToken);

    let companyConfig = null; // Store business configuration
    let calendar; // Declare calendar variable

    // Fetch business configuration
    fetch('/api/business_config', {
        method: 'GET',
        headers: {
            'Content-Type': 'application/json'
        }
    })
    .then(response => {
        if (!response.ok) {
            throw new Error('Failed to fetch business configuration');
        }
        return response.json();
    })
    .then(data => {
        companyConfig = data;
        console.debug('Business configuration loaded:', companyConfig);
        initializeCalendar();
    })
    .catch(error => {
        console.error('Error fetching business configuration:', error);
        // Fallback to defaults
        companyConfig = {
            company_timezone: 'America/Denver',
            business_start_time: '08:00',
            business_end_time: '17:00',
            buffer_time_minutes: 30
        };
        initializeCalendar();
    });

    function initializeCalendar() {
        if (typeof FullCalendar !== 'undefined') {
            try {
                calendar = new FullCalendar.Calendar(calendarEl, {
                    initialView: 'dayGridMonth',
                    selectable: true,
                    headerToolbar: {
                        left: 'prev,next today',
                        center: 'title',
                        right: 'dayGridMonth,listMonth'
                    },
                    events: '/api/upcoming_appointments',
                    eventColor: '#378006',
                    timeZone: companyConfig.company_timezone, // Use company timezone

                    select: function(info) {
                        console.debug('Date selected:', info.startStr);
                        highlightDate(info.startStr);
                        handleDateSelection(info.startStr);
                    },

                    dateClick: function(info) {
                        console.debug('Date clicked:', info.dateStr);
                        highlightDate(info.dateStr);
                        handleDateSelection(info.dateStr);
                    }
                });

                console.debug('Calendar initialized successfully.');
                calendar.render();
                console.debug('Calendar rendered.');
            } catch (error) {
                console.error('Error initializing or rendering FullCalendar:', error);
            }
        } else {
            console.error('FullCalendar is not defined.');
        }
    }

    // Touch event listener for date selection on mobile
    calendarEl.addEventListener('touchstart', function(event) {
        console.debug('Touchstart event detected:', event);
        const touch = event.touches[0];
        const targetElement = document.elementFromPoint(touch.clientX, touch.clientY);
        console.debug('Touch event detected on element:', targetElement);
        if (targetElement && targetElement.hasAttribute('data-date')) {
            const dateStr = targetElement.getAttribute('data-date');
            console.debug('Date string from touch event:', dateStr);
            if (dateStr) {
                highlightDate(dateStr);
                handleDateSelection(dateStr);
            }
        }
    }, { passive: true });

    // Date input listener
    addDateInputListener();

    function addDateInputListener() {
        const dateInput = document.getElementById('preferred_date');
        dateInput.addEventListener('change', function() {
            const selectedDate = this.value;
            if (selectedDate) {
                handleDateInputChange(selectedDate);
            }
        });
    }

    function handleDateInputChange(dateStr) {
        console.debug('Date input changed:', dateStr);
        const date = new Date(dateStr + 'T00:00:00');
        calendar.select(date);
        highlightDate(dateStr);
        handleDateSelection(dateStr);
    }

    function highlightDate(dateStr) {
        document.querySelectorAll('.selected-date').forEach(cell => {
            cell.classList.remove('selected-date');
        });
        const selectedCell = document.querySelector(`[data-date="${dateStr}"]`);
        if (selectedCell) {
            selectedCell.classList.add('selected-date');
        }
    }

    function handleDateSelection(dateStr) {
        console.debug('Handling date selection:', dateStr);
        document.getElementById('preferred_date').value = dateStr;
        console.debug('Preferred date set to:', dateStr);

        fetch('/get_available_time_slots', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrfToken
            },
            body: JSON.stringify({
                date: dateStr,
                timezone: userTimezone
            })
        })
        .then(response => {
            console.debug('Fetch response:', response);
            if (!response.ok) {
                throw new Error('Network response was not ok');
            }
            return response.json();
        })
        .then(data => {
            console.debug('Time slots data received:', data);
            populateTimeSlots(data, userTimezone, companyConfig.company_timezone);
        })
        .catch(error => {
            console.error('Error fetching time slots:', error);
            const timeDropdown = document.getElementById('preferred_time');
            timeDropdown.innerHTML = '<option disabled>Error loading time slots</option>';
        });
    }

    nextButton.addEventListener('click', handleNextButtonClick);
    nextButton.addEventListener('touchstart', handleNextButtonClick, { passive: true });

    function handleNextButtonClick(event) {
        event.preventDefault();
        console.debug('"Next" button clicked.');
        const form = document.getElementById('personal-info-form');
        console.debug('Personal info form element:', form);

        if (form.checkValidity()) {
            console.debug('Personal info form validation successful.');
            copyPersonalInfoToStep2();
            step1.style.display = 'none';
            step2.style.display = 'block';
            calendarContainer.style.display = 'block';
            console.debug('Navigating to Step 2 and showing the calendar.');
            calendarContainer.offsetHeight; // Force reflow
            calendar.render();
        } else {
            console.warn('Personal info form validation failed.');
            form.reportValidity();
        }
    }
});

function copyPersonalInfoToStep2() {
    const form = document.getElementById('personal-info-form');
    console.debug('Copying personal info from form:', form);
    document.getElementById('hidden_first_name').value = form.querySelector('[name="first_name"]').value;
    document.getElementById('hidden_last_name').value = form.querySelector('[name="last_name"]').value;
    document.getElementById('hidden_phone').value = form.querySelector('[name="phone"]').value;
    document.getElementById('hidden_email').value = form.querySelector('[name="email"]').value;
    console.debug('Personal info copied to Step 2.');
}

function convertUTCToLocal(utcTimeStr, targetTimezone, showUserTimezone = false, userTimezone = null) {
    console.debug('Converting UTC time:', utcTimeStr, 'to timezone:', targetTimezone);
    const utcDateTime = new Date(utcTimeStr);
    if (isNaN(utcDateTime)) {
        console.error('Invalid UTC Date string:', utcTimeStr);
        return 'Invalid Date';
    }

    const formatter = new Intl.DateTimeFormat('en-US', {
        timeZone: targetTimezone,
        hour: '2-digit',
        minute: '2-digit',
        hour12: true
    });

    let localTime = formatter.format(utcDateTime);
    if (showUserTimezone && userTimezone && userTimezone !== targetTimezone) {
        const userFormatter = new Intl.DateTimeFormat('en-US', {
            timeZone: userTimezone,
            hour: '2-digit',
            minute: '2-digit',
            hour12: true
        });
        const userTime = userFormatter.format(utcDateTime);
        localTime += ` (${userTime})`;
    }

    console.debug('Converted UTC to local time:', utcTimeStr, '->', localTime);
    return localTime;
}

function populateTimeSlots(data, userTimezone, companyTimezone) {
    console.debug('Populating time slots with data:', data, 'company timezone:', companyTimezone);
    const timeDropdown = document.getElementById('preferred_time');
    timeDropdown.innerHTML = '';

    if (data.timeSlots.length === 0) {
        const option = document.createElement('option');
        option.textContent = 'No available slots';
        option.disabled = true;
        timeDropdown.appendChild(option);
        console.warn('No available time slots for the selected date.');
    } else {
        data.timeSlots.forEach(slot => {
            // Display time in company timezone, with user timezone in parentheses
            const localTime = convertUTCToLocal(slot, companyTimezone, true, userTimezone);
            const option = document.createElement('option');
            option.value = slot;
            option.textContent = localTime;
            timeDropdown.appendChild(option);
        });
        console.debug('Time slots populated in dropdown.');
    }
}

C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\LICENSE:
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright 2025 Verso Industries (Author: Michael B. Zimmerman)

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.


C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\models.py:
from datetime import datetime
from flask_login import UserMixin
from itsdangerous import URLSafeTimedSerializer
import flask
from flask import current_app
import enum
from .extensions import bcrypt
import sqlalchemy
from app.database import db
from datetime import datetime, timedelta
from sqlalchemy.exc import SQLAlchemyError
from sqlalchemy_utils import ChoiceType
import json
from sqlalchemy import JSON, event, Index
from sqlalchemy.sql import func
from sqlalchemy.ext.mutable import MutableList
import pytz


user_roles = db.Table('user_roles',
    db.Column('user_id', db.Integer, db.ForeignKey('user.id'), primary_key=True),
    db.Column('role_id', db.Integer, db.ForeignKey('role.id'), primary_key=True)
)

class User(UserMixin, db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True, nullable=False)
    password_hash = db.Column(db.String(128), nullable=False)
    email = db.Column(db.String(120), unique=True, nullable=False)
    confirmed = db.Column(db.Boolean, default=False)
    confirmed_on = db.Column(db.DateTime, nullable=True)
    reset_token = db.Column(db.String(120), nullable=True)
    roles = db.relationship('Role', secondary=user_roles, back_populates='users')
    phone = db.Column(db.String(20), nullable=True)
    date = db.Column(db.DateTime, default=datetime.utcnow)
    tos_accepted = db.Column(db.Boolean, default=False, nullable=False)
    first_name = db.Column(db.String(100), nullable=True)  # New field for first name
    last_name = db.Column(db.String(100), nullable=True)  # New field for last name

    def __init__(self, username, email, password):
        self.username = username
        self.email = email
        self.set_password(password)  # Use the method to hash the password

    def set_password(self, password):
        self.password_hash = bcrypt.generate_password_hash(password).decode('utf-8')

    def check_password(self, password):
        return bcrypt.check_password_hash(self.password_hash, password)

    def generate_reset_token(self, expiration=3600):
        s = URLSafeTimedSerializer(current_app.config['SECRET_KEY'])
        return s.dumps({'id': self.id}, salt='password-reset-salt')

    @staticmethod
    def confirm_reset_token(token, expiration=3600):
        s = URLSafeTimedSerializer(current_app.config['SECRET_KEY'])
        try:
            data = s.loads(token, salt='password-reset-salt', max_age=expiration)
        except:
            return None
        return User.query.get(data['id'])

    def has_role(self, role_name):
        return any(role.name == role_name for role in self.roles)

    def add_role(self, role):
        if not self.has_role(role.name):
            self.roles.append(role)

    def remove_role(self, role):
        if self.has_role(role.name):
            self.roles.remove(role)

    def __repr__(self):
        return f'<User username={self.username} email={self.email}>'
    
class Role(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(50), unique=True, nullable=False)
    users = db.relationship('User', secondary=user_roles, back_populates='roles')

    def __repr__(self):
        return f'<Role {self.name}>'

class Service(db.Model):
    __tablename__ = 'service'
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    description = db.Column(db.String(255))
    display_order = db.Column(db.Integer, default=0)

class Appointment(db.Model):
    __tablename__ = 'appointment'
    id = db.Column(db.Integer, primary_key=True)
    first_name = db.Column(db.String(100), nullable=False)
    last_name = db.Column(db.String(100), nullable=False)
    phone = db.Column(db.String(20), nullable=False)
    email = db.Column(db.String(100), nullable=False)
    preferred_date_time = db.Column(db.DateTime, nullable=False)  # Ensure this is stored as UTC
    service_id = db.Column(db.Integer, db.ForeignKey('service.id'), nullable=True)
    estimator_id = db.Column(db.Integer, db.ForeignKey('estimator.id'), nullable=False)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)  # UTC by default for created_at
    updated_at = db.Column(db.DateTime, onupdate=datetime.utcnow)  # UTC by default for updated_at

    # Relationships
    estimator = db.relationship('Estimator', backref=db.backref('appointments', lazy=True))
    service = db.relationship('Service', backref=db.backref('appointments', lazy=True))

    def to_dict(self):
        return {
            'id': self.id,
            'first_name': self.first_name,
            'last_name': self.last_name,
            'phone': self.phone,
            'email': self.email,
            'preferred_date_time': self.preferred_date_time.isoformat() if self.preferred_date_time else None,
            'service_id': self.service_id,
            'estimator_id': self.estimator_id,
            'created_at': self.created_at.isoformat() if self.created_at else None,
            'updated_at': self.updated_at.isoformat() if self.updated_at else None,
            'service': self.service.name if self.service else None,
            'estimator': self.estimator.name if self.estimator else None
        }

    # To ensure timestamps are always stored as UTC
    @staticmethod
    def to_utc(naive_datetime):
        """Converts a naive datetime to UTC"""
        return pytz.utc.localize(naive_datetime)

    @staticmethod
    def from_utc(utc_datetime):
        """Converts a UTC datetime to naive local time if needed"""
        return utc_datetime.astimezone(pytz.utc).replace(tzinfo=None)
    
@event.listens_for(Appointment, "before_insert")
def receive_before_insert(mapper, connection, target):
    # Make sure 'created_at' is always UTC
    target.created_at = datetime.utcnow()

@event.listens_for(Appointment, "before_update")
def receive_before_update(mapper, connection, target):
    # Make sure 'updated_at' is always UTC
    target.updated_at = datetime.utcnow()

class Estimator(db.Model):
    __tablename__ = 'estimator'
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)

class ContactFormSubmission(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    first_name = db.Column(db.String(100), nullable=False)
    last_name = db.Column(db.String(100), nullable=False)
    email = db.Column(db.String(120), nullable=False)
    phone = db.Column(db.String(20), nullable=False)
    message = db.Column(db.Text, nullable=False)
    submitted_at = db.Column(db.DateTime, default=datetime.utcnow)

class BusinessConfig(db.Model):
    __tablename__ = 'business_config'
    id = db.Column(db.Integer, primary_key=True)
    setting_name = db.Column(db.String(100), unique=True, nullable=False)
    setting_value = db.Column(db.String(255), nullable=False)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    def __repr__(self):
        return f'<BusinessConfig {self.setting_name}={self.setting_value}>'
    
class Post(db.Model):
    __tablename__ = 'post'
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(200), nullable=False)
    slug = db.Column(db.String(200), unique=True, nullable=False)
    content = db.Column(db.Text, nullable=False)
    category = db.Column(db.String(100), nullable=True)
    author_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    created_at = db.Column(db.DateTime, default=datetime.utcnow, nullable=False)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)
    is_published = db.Column(db.Boolean, default=False, nullable=False)
    image = db.Column(db.LargeBinary, nullable=True)  # Store image as BLOB
    image_mime_type = db.Column(db.String(50), nullable=True)  # Store MIME type (e.g., image/png)

    # Relationships
    author = db.relationship('User', backref=db.backref('posts', lazy=True))

    __table_args__ = (
        Index('idx_post_slug', 'slug'),  # Index for faster slug lookups
    )

    def __repr__(self):
        return f'<Post title={self.title} slug={self.slug}>'

@event.listens_for(Post, "before_insert")
def post_before_insert(mapper, connection, target):
    # Ensure created_at is always UTC
    target.created_at = datetime.utcnow()

@event.listens_for(Post, "before_update")
def post_before_update(mapper, connection, target):
    # Ensure updated_at is always UTC
    target.updated_at = datetime.utcnow()

C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\forms.py:
from flask_wtf import FlaskForm
import os
from flask import current_app
from wtforms import (StringField, PasswordField, SubmitField, BooleanField, IntegerField, SelectField, TextAreaField, DateField, DecimalField, FieldList, FormField,
                      FileField, FileField, FloatField, SelectMultipleField, HiddenField, ValidationError, EmailField, SubmitField, Form, FloatField, StringField )
from wtforms.fields import DateField, EmailField, TelField, DateTimeField
from wtforms.validators import DataRequired, Length, Email, EqualTo, ValidationError, Optional, NumberRange, Regexp, URL
from sqlalchemy import text
from flask_wtf import FlaskForm
from wtforms import StringField, PasswordField, BooleanField, SubmitField
from wtforms.validators import DataRequired, Email, Length, EqualTo
from app.models import Role, Service, Estimator
import pytz
from datetime import datetime, timedelta
from flask_ckeditor import CKEditorField

class RegistrationForm(FlaskForm):
    username = StringField('Username', validators=[DataRequired(), Length(min=3, max=100)])
    first_name = StringField('First Name', validators=[DataRequired(), Length(min=1, max=100)])
    last_name = StringField('Last Name', validators=[DataRequired(), Length(min=1, max=100)])
    email = StringField('Email', validators=[DataRequired(), Email()])
    password = PasswordField('Password', validators=[DataRequired(), Length(min=6, max=100)])
    confirm_password = PasswordField('Confirm Password', validators=[DataRequired(), EqualTo('password')])
    role = SelectField('Role', coerce=int, validators=[DataRequired()])
    accept_tos = BooleanField('I accept the Terms and Conditions', validators=[DataRequired()])
    submit = SubmitField('Sign Up')

    def __init__(self, *args, **kwargs):
        super(RegistrationForm, self).__init__(*args, **kwargs)
        self.role.choices = [(role.id, role.name) for role in Role.query.filter(Role.name != 'admin').all()]

class AcceptTOSForm(FlaskForm):
    accept_tos = BooleanField('I agree to the Terms and Conditions', validators=[DataRequired()])
    submit = SubmitField('Accept')

class ForgotPasswordForm(FlaskForm):
    email = StringField('Email', validators=[DataRequired(), Email()])
    submit = SubmitField('Request Password Reset')

class ResetPasswordForm(FlaskForm):
    password = PasswordField('New Password', validators=[DataRequired(), Length(min=6, max=100)])
    confirm_password = PasswordField('Confirm New Password', validators=[DataRequired(), EqualTo('password')])
    submit = SubmitField('Reset Password')

class LoginForm(FlaskForm):
    email = StringField('Email', validators=[DataRequired(), Email()])
    password = PasswordField('Password', validators=[DataRequired()])
    submit = SubmitField('Login')

class SettingsForm(FlaskForm):
    email = StringField('Email', validators=[DataRequired(), Email()])
    username = StringField('Username', validators=[DataRequired()])
    password = PasswordField('Password', validators=[DataRequired()])
    confirm_password = PasswordField('Confirm Password', validators=[EqualTo('password')])
    submit = SubmitField('Update Settings')

class ManageRolesForm(FlaskForm):
    def __init__(self, *args, **kwargs):
        super(ManageRolesForm, self).__init__(*args, **kwargs)
        self.roles.choices = [(role.id, role.name) for role in Role.query.all()]

    roles = SelectMultipleField(
        'Roles',
        coerce=int,  # Coerce form data to integer, as role IDs are integers
        validators=[DataRequired()]
    )
    submit = SubmitField('Update Roles')


class RoleSelectForm(Form):
    def __init__(self, *args, **kwargs):
        super(RoleSelectForm, self).__init__(*args, **kwargs)
        self.role.choices = [(role.id, role.name) for role in Role.query.all()]

class EditUserForm(FlaskForm):
    username = StringField('Username', validators=[DataRequired(), Length(min=2, max=50)])
    email = EmailField('Email', validators=[DataRequired(), Email()])
    is_active = BooleanField('Active User')

    submit = SubmitField('Update')

class EstimateRequestForm(FlaskForm):
    first_name = StringField('First Name', validators=[DataRequired(), Length(max=100)])
    last_name = StringField('Last Name', validators=[DataRequired(), Length(max=100)])
    phone = TelField('Phone Number', validators=[DataRequired()])
    email = EmailField('Email Address', validators=[DataRequired(), Email()])
    preferred_date = DateField('Preferred Date', format='%Y-%m-%d', validators=[DataRequired()])
    preferred_time = SelectField('Preferred Time', validators=[DataRequired()])
    estimator = SelectField('Select Estimator', coerce=int, validators=[DataRequired()])
    service = SelectField('Select Service', coerce=int, validators=[DataRequired()])  # Renamed from plan_option
    submit = SubmitField('Request Free Estimate')
    
    def __init__(self, *args, **kwargs):
        super(EstimateRequestForm, self).__init__(*args, **kwargs)
        self.service.choices = [(0, 'Please Select a Service')] + [(s.id, s.name) for s in Service.query.order_by('display_order').all()]  # Updated to Service
        self.estimator.choices = [(0, 'Please Select an Estimator')] + [(e.id, e.name) for e in Estimator.query.order_by('name').all()]
        self.preferred_time.choices = [(0, 'Please Select a Time')]

class EstimatorForm(FlaskForm):
    name = StringField('Name', validators=[DataRequired()])
    submit = SubmitField('Submit')

class ServiceOptionForm(FlaskForm):  
    name = StringField('Service Name', validators=[DataRequired()])  
    description = StringField('Service Description', validators=[Optional()])  
    display_order = IntegerField('Display Order', validators=[Optional(), NumberRange(min=0)])
    submit = SubmitField('Add Service')  

class ContactForm(FlaskForm):
    first_name = StringField('First Name', validators=[DataRequired(), Length(max=100)])
    last_name = StringField('Last Name', validators=[DataRequired(), Length(max=100)])
    email = StringField('Email', validators=[DataRequired(), Email(), Length(max=120)])
    phone = StringField('Phone Number', validators=[DataRequired(), Length(max=20)])
    message = TextAreaField('Message', validators=[DataRequired()])
    submit = SubmitField('Send Message')

class CSRFTokenForm(FlaskForm):
    csrf_token = HiddenField()

class EditUserForm(FlaskForm):
    username = StringField('Username', validators=[DataRequired()])
    email = StringField('Email', validators=[DataRequired(), Email()])
    first_name = StringField('First Name')
    last_name = StringField('Last Name')
    phone = StringField('Phone')
    password = PasswordField('New Password')
    roles = SelectMultipleField('Roles', coerce=int)
    submit = SubmitField('Update User')

class CreateUserForm(FlaskForm):
    username = StringField('Username', validators=[DataRequired()])
    email = StringField('Email', validators=[DataRequired(), Email()])
    password = PasswordField('Password', validators=[DataRequired()])
    first_name = StringField('First Name')
    last_name = StringField('Last Name')
    phone = StringField('Phone')
    roles = SelectMultipleField('Roles', coerce=int)
    submit = SubmitField('Create User')

class RoleForm(FlaskForm):
    name = StringField('Role Name', validators=[DataRequired()])
    submit = SubmitField('Save')

def generate_time_choices(start_hour=0, end_hour=23, interval_minutes=30):
    """Generate time choices in HH:MM format for a given interval."""
    choices = []
    current_time = datetime.strptime("00:00", "%H:%M")
    end_time = datetime.strptime("23:59", "%H:%M")
    delta = timedelta(minutes=interval_minutes)
    
    while current_time <= end_time:
        time_str = current_time.strftime("%H:%M")
        choices.append((time_str, time_str))
        current_time += delta
    
    return choices

class BusinessConfigForm(FlaskForm):
    business_start_time = SelectField(
        'Business Start Time (HH:MM, 24-hour format)',
        choices=generate_time_choices(),
        validators=[DataRequired()]
    )
    business_end_time = SelectField(
        'Business End Time (HH:MM, 24-hour format)',
        choices=generate_time_choices(),
        validators=[DataRequired()]
    )
    buffer_time_minutes = SelectField(
        'Buffer Time Between Appointments (Minutes)',
        choices=[(15, '15'), (30, '30'), (45, '45'), (60, '60'), (90, '90'), (120, '120')],
        coerce=int,
        validators=[DataRequired()]
    )
    company_timezone = SelectField(
        'Company Timezone',
        choices=[(tz, tz) for tz in pytz.all_timezones],
        validators=[DataRequired()]
    )
    submit = SubmitField('Save Settings')

class CreatePostForm(FlaskForm):
    title = StringField('Title', validators=[DataRequired(), Length(max=200)])
    content = CKEditorField('Content', validators=[DataRequired()])  # Changed to CKEditorField
    category = StringField('Category', validators=[Optional(), Length(max=100)])
    is_published = BooleanField('Publish Post', default=False)
    image = FileField('Post Image', validators=[Optional()])
    submit = SubmitField('Create Post')

    def validate_title(self, title):
        """Ensure title is not empty after stripping whitespace."""
        if not title.data.strip():
            raise ValidationError('Title cannot be empty.')

    def validate_image(self, image):
        """Validate image file type and size."""
        if image.data:
            allowed_extensions = {'png', 'jpg', 'jpeg'}
            max_size = 5 * 1024 * 1024  # 5MB
            filename = image.data.filename
            extension = os.path.splitext(filename)[1].lower().lstrip('.')
            if extension not in allowed_extensions:
                raise ValidationError('Only PNG, JPG, and JPEG files are allowed.')
            # Check file size
            image.data.seek(0, os.SEEK_END)
            file_size = image.data.tell()
            if file_size > max_size:
                raise ValidationError('Image file size must be less than 5MB.')
            image.data.seek(0)  # Reset file pointer

class EditPostForm(FlaskForm):
    title = StringField('Title', validators=[DataRequired(), Length(max=200)])
    content = CKEditorField('Content', validators=[DataRequired()])  # Replace TextAreaField
    category = StringField('Category', validators=[Optional(), Length(max=100)])
    is_published = BooleanField('Publish Post')
    image = FileField('Post Image', validators=[Optional()])
    submit = SubmitField('Update Post')

    def validate_title(self, title):
        """Ensure title is not empty after stripping whitespace."""
        if not title.data.strip():
            raise ValidationError('Title cannot be empty.')

    def validate_image(self, image):
        """Validate image file type and size."""
        if image.data:
            allowed_extensions = {'png', 'jpg', 'jpeg'}
            max_size = 5 * 1024 * 1024  # 5MB
            filename = image.data.filename
            extension = os.path.splitext(filename)[1].lower().lstrip('.')
            if extension not in allowed_extensions:
                raise ValidationError('Only PNG, JPG, and JPEG files are allowed.')
            image.data.seek(0, os.SEEK_END)
            file_size = image.data.tell()
            if file_size > max_size:
                raise ValidationError('Image file size must be less than 5MB.')
            image.data.seek(0)  # Reset file pointer

C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\routes\user.py:
from flask import Blueprint, render_template, redirect, url_for, flash, request, current_app, session, jsonify
from flask_login import login_user, logout_user, login_required, current_user
import app
import os
from app import db, mail, bcrypt  # Adjust 'app' to your actual app's name
from app.models import User
from app.forms import RegistrationForm, LoginForm, SettingsForm, EstimateRequestForm
from flask_mail import Message
from datetime import datetime, timedelta, date
import logging
from sqlalchemy import and_, cast, String

user = Blueprint('user', __name__)

@user.context_processor
def combined_context_processor():
    erf_form = EstimateRequestForm()
    return dict(erf_form=erf_form)

@user.route('/reset_password', methods=['POST'])
def reset_password():
    token = request.form.get('token')
    password = request.form.get('password')
    user = User.verify_reset_token(token)
    if user:
        hashed_password = bcrypt.generate_password_hash(password).decode('utf-8')
        user.password = hashed_password
        db.session.commit()
        flash('Your password has been updated!', 'success')
        return redirect(url_for('auth.login'))
    else:
        flash('That is an invalid or expired token', 'warning')
        return redirect(url_for('main.register'))

@user.route('/settings', methods=['GET', 'POST'])
@login_required
def settings():
    settings_form = SettingsForm()

    if settings_form.validate_on_submit():
        current_user.email = settings_form.email.data
        current_user.bio = settings_form.bio.data
        current_user.location = settings_form.location.data

        if settings_form.password.data:
            current_user.set_password(settings_form.password.data)  # Assuming you have a set_password method

        db.session.commit()
        flash('Your changes have been saved.')
        return redirect(url_for('main.settings'))

    elif request.method == 'GET':
        settings_form.email.data = current_user.email
        settings_form.bio.data = current_user.bio
        settings_form.location.data = current_user.location

    return render_template('settings.html', settings_form=settings_form)

@user.route('/dashboard')
@login_required
def dashboard():

    return render_template('UserDashboard/user_dashboard.html')


@user.route('/dashboard/commercial')
@login_required
def commercial_dashboard():
    if not current_user.has_role('commercial'):
        flash('Access denied. This area is for commercial users only.', 'danger')
        return redirect(url_for('user.dashboard'))


    return render_template(
        'UserDashboard/commercial_dashboard.html'
    )


C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\Procfile:
web: gunicorn "app:create_app()"

C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\routes\__init__.py:


C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\routes\main_routes.py:
import os
from datetime import datetime, time, timedelta
import icalendar
import pytz
import requests
from dateutil import parser
from flask import (Blueprint, Response, current_app, flash, jsonify,
                   redirect, render_template, request, session,
                   url_for)
from flask_login import current_user, login_required
from markupsafe import Markup
from pytz import UTC

from app import csrf, db, mail
from app.forms import AcceptTOSForm, EstimateRequestForm, ContactForm
from app.models import Appointment, Estimator, Service, User, ContactFormSubmission, BusinessConfig
from app.modules.locations import get_locations
import random

main = Blueprint('main_routes', __name__)

@main.context_processor
def combined_context_processor():
    locations = get_locations()
    erf_form = EstimateRequestForm()
    return dict(locations=locations, erf_form=erf_form)

@main.route('/')
def index():
    # For regular user visitors, include the gallery logic
    image_folder = os.path.join(current_app.static_folder, 'images/gallery')
    gallery_images = [f for f in os.listdir(image_folder) if os.path.isfile(os.path.join(image_folder, f))]
    random.shuffle(gallery_images)

    page = int(request.args.get('page', 1))
    per_page = 5
    total_images = len(gallery_images)
    start = (page - 1) * per_page
    end = start + per_page

    paginated_images = gallery_images[start:end]
    has_more = end < total_images
    # Check for bot user agents in the request
    bot_agents = ['Googlebot', 'Bingbot', 'Slurp', 'DuckDuckBot', 'Baiduspider', 'YandexBot', 'Sogou']
    user_agent = request.headers.get('User-Agent', '')
    if any(bot in user_agent for bot in bot_agents):
        # Serve a static version of the homepage suitable for indexing
        return render_template('index.html', gallery_images=paginated_images, has_more=has_more, page=page)

    # For authenticated users, redirect based on their role
    if current_user.is_authenticated:
        if current_user.has_role('commercial'):
            return redirect(url_for('user.commercial_dashboard'))
        else:
            return redirect(url_for('user.dashboard'))

    # For regular user visitors, include the gallery logic
    image_folder = os.path.join(current_app.static_folder, 'images/gallery')
    gallery_images = [f for f in os.listdir(image_folder) if os.path.isfile(os.path.join(image_folder, f))]
    random.shuffle(gallery_images)

    page = int(request.args.get('page', 1))
    per_page = 5
    total_images = len(gallery_images)
    start = (page - 1) * per_page
    end = start + per_page

    paginated_images = gallery_images[start:end]
    has_more = end < total_images

    return render_template('index.html', gallery_images=paginated_images, has_more=has_more, page=page)

@main.route('/accept-terms', methods=['GET', 'POST'])
@login_required
def accept_terms():
    form = AcceptTOSForm()
    if form.validate_on_submit() and form.accept_tos.data:
        current_user.tos_accepted = True
        current_user.tos_accepted_on = datetime.utcnow()
        db.session.commit()
        flash('Thank you for accepting the terms of service.', 'success')
        return redirect(url_for('main_routes.index'))
    return render_template('accept_terms.html', form=form)

@main.route('/about')
def about():
    return render_template('aboutus.html')

@main.route('/services')
def services():
    return render_template('services.html')

@main.route('/contact', methods=['GET', 'POST'])
def contact():
    form = ContactForm()
    if form.validate_on_submit():
        submission = ContactFormSubmission(
            first_name=form.first_name.data,
            last_name=form.last_name.data,
            email=form.email.data,
            phone=form.phone.data,
            message=form.message.data
        )
        db.session.add(submission)
        db.session.commit()
        return redirect(url_for('main_routes.contact_confirmation'))
    return render_template('contact.html', form=form)

@main.route('/contact-confirmation')
def contact_confirmation():
    return render_template('contact_confirmation.html')   

@main.route('/request_estimate', methods=['POST'])
def request_estimate():
    form = EstimateRequestForm()

    if request.method == 'POST':
        current_app.logger.info(f"Form data received: {request.form}")

        selected_date = request.form.get('preferred_date')
        user_timezone_str = request.form.get('timezone', 'America/Denver')
        user_timezone = pytz.timezone(user_timezone_str)

        if selected_date:
            try:
                response = requests.post(
                    url_for('main_routes.get_available_time_slots', _external=True),
                    json={'date': selected_date, 'timezone': user_timezone_str},
                    headers={'Content-Type': 'application/json'},
                    timeout=10
                )
                response.raise_for_status()
                time_slots_data = response.json()
                time_slots = time_slots_data.get('timeSlots', [])

                form.preferred_time.choices = [(slot, convert_utc_to_local(slot, user_timezone)) for slot in time_slots]
            except requests.exceptions.RequestException as e:
                current_app.logger.error(f"Error fetching time slots: {e}")
                flash('There was an error fetching available time slots.', 'danger')
                return redirect(url_for('main_routes.index'))

        if form.validate_on_submit():
            current_app.logger.info("Form validation successful.")
            
            try:
                preferred_date_time = parser.isoparse(form.preferred_time.data)
                current_app.logger.info(f"Parsed preferred date and time: {preferred_date_time}")

                if preferred_date_time.tzinfo is None:
                    preferred_date_time_localized = user_timezone.localize(preferred_date_time)
                    current_app.logger.info(f"Localized preferred date and time: {preferred_date_time_localized}")
                else:
                    preferred_date_time_localized = preferred_date_time.astimezone(user_timezone)
                    current_app.logger.info(f"Converted preferred date and time to user's timezone: {preferred_date_time_localized}")

                preferred_date_time_utc = preferred_date_time_localized.astimezone(pytz.utc)
                current_app.logger.info(f"Preferred time (UTC): {preferred_date_time_utc}")
            except Exception as e:
                current_app.logger.error(f"Error parsing date and time: {e}")
                flash('There was an error with the selected date or time.', 'danger')
                return redirect(url_for('main_routes.index'))

            try:
                appointment = Appointment(
                    first_name=form.first_name.data,
                    last_name=form.last_name.data,
                    phone=form.phone.data,
                    email=form.email.data,
                    preferred_date_time=preferred_date_time_utc,
                    service_id=form.service.data,
                    estimator_id=form.estimator.data
                )
                db.session.add(appointment)
                db.session.commit()
                current_app.logger.info(f"Appointment created: {appointment}")

                flash('Your estimate request has been submitted.', 'success')
                return redirect(url_for('main_routes.estimate_submitted',
                                        estimator=form.estimator.data,
                                        date=preferred_date_time.strftime('%Y-%m-%d'),
                                        time=preferred_date_time.strftime('%H:%M')))
            except Exception as e:
                current_app.logger.error(f"Error creating appointment: {e}")
                flash('There was an error processing your request.', 'danger')
                return redirect(url_for('main_routes.index'))
        else:
            current_app.logger.info("Form validation failed.")
            for field, errors in form.errors.items():
                for error in errors:
                    current_app.logger.error(f"Error in {field}: {error}")

    return redirect(url_for('main_routes.index'))

def convert_utc_to_local(utc_time_str, user_timezone):
    utc_date_time = datetime.fromisoformat(utc_time_str.replace('Z', '+00:00'))
    local_date_time = utc_date_time.astimezone(user_timezone)
    return local_date_time.strftime('%Y-%m-%d %H:%M:%S')

def get_upcoming_appointments():
    now = datetime.utcnow()
    return Appointment.query.filter(Appointment.preferred_date_time > now).all()

@main.route('/api/upcoming_appointments')
@csrf.exempt
def api_upcoming_appointments():
    try:
        appointments = get_upcoming_appointments()
        if appointments is None:
            current_app.logger.info("No upcoming appointments found.")
            return jsonify([]), 200

        appointments_data = [{
            'start': appointment.preferred_date_time.replace(tzinfo=pytz.utc).isoformat(),
            'end': (appointment.preferred_date_time + timedelta(hours=1)).replace(tzinfo=pytz.utc).isoformat()
        } for appointment in appointments]
        return jsonify(appointments_data), 200
    except Exception as e:
        current_app.logger.error(f"An error occurred fetching appointments: {e}")
        return jsonify({'error': 'An error occurred fetching appointments'}), 500

@main.route('/get_available_time_slots', methods=['POST'])
@csrf.exempt
def get_available_time_slots():
    data = request.json
    current_app.logger.info(f"Received data: {data}")

    if 'date' not in data or 'timezone' not in data:
        current_app.logger.error('Missing date or timezone in request')
        return jsonify({'error': 'Missing date or timezone'}), 400

    try:
        selected_date = datetime.strptime(data['date'], '%Y-%m-%d').date()
        user_timezone_str = data['timezone']
        user_timezone = pytz.timezone(user_timezone_str)
        current_app.logger.info(f"User's timezone: {user_timezone_str}")
    except (ValueError, pytz.UnknownTimeZoneError) as e:
        current_app.logger.error(f"Error parsing date or timezone: {e}")
        return jsonify({'error': 'Invalid date or timezone format'}), 400

    # Load business configuration
    configs = BusinessConfig.query.all()
    config_dict = {config.setting_name: config.setting_value for config in configs}
    
    # Default values if not set
    business_start_time_str = config_dict.get('business_start_time', '08:00')
    business_end_time_str = config_dict.get('business_end_time', '17:00')
    buffer_time_minutes = int(config_dict.get('buffer_time_minutes', 30))
    company_timezone_str = config_dict.get('company_timezone', 'America/Denver')

    try:
        company_timezone = pytz.timezone(company_timezone_str)
        business_start_time = datetime.strptime(business_start_time_str, '%H:%M').time()
        business_end_time = datetime.strptime(business_end_time_str, '%H:%M').time()
    except (ValueError, pytz.UnknownTimeZoneError) as e:
        current_app.logger.error(f"Error parsing business config: {e}")
        return jsonify({'error': 'Invalid business configuration'}), 500

    start_time_local = datetime.combine(selected_date, business_start_time)
    end_time_local = datetime.combine(selected_date, business_end_time)

    start_time_localized = company_timezone.localize(start_time_local)
    end_time_localized = company_timezone.localize(end_time_local)

    start_time_utc = start_time_localized.astimezone(pytz.UTC)
    end_time_utc = end_time_localized.astimezone(pytz.UTC)

    time_slots = []
    current_time_utc = start_time_utc

    while current_time_utc < end_time_utc:
        existing_appointment = Appointment.query.filter_by(preferred_date_time=current_time_utc).first()
        
        if not existing_appointment:
            user_time_slot = current_time_utc.astimezone(user_timezone)
            time_slots.append(user_time_slot.isoformat())
        
        current_time_utc += timedelta(minutes=buffer_time_minutes)

    current_app.logger.info(f"Generated time slots in ISO format (UTC): {time_slots}")
    
    return jsonify({'timeSlots': time_slots})

@main.route('/estimate_submitted')
def estimate_submitted():
    referrer = request.args.get('referrer', url_for('main_routes.index'))
    estimator_id = request.args.get('estimator')
    date = request.args.get('date')
    time = request.args.get('time')

    # Query the Estimator model to get the name based on the ID
    estimator = None
    if estimator_id:
        try:
            estimator_obj = Estimator.query.get(int(estimator_id))
            if estimator_obj:
                estimator = estimator_obj.name
            else:
                current_app.logger.error(f"Estimator with ID {estimator_id} not found.")
                estimator = "Unknown Estimator"  # Fallback for invalid ID
        except ValueError:
            current_app.logger.error(f"Invalid estimator ID format: {estimator_id}")
            estimator = "Unknown Estimator"  # Fallback for non-integer ID
    else:
        current_app.logger.error("No estimator ID provided in request.")
        estimator = "Unknown Estimator"  # Fallback if no ID is provided

    try:
        time_obj = datetime.strptime(time, '%H:%M')
        formatted_time = time_obj.strftime('%I:%M %p')
    except ValueError as e:
        current_app.logger.error(f"Error parsing time: {e}")
        formatted_time = time  # Fallback to raw time if parsing fails

    return render_template(
        'estimate_submitted.html',
        referrer=referrer,
        estimator=estimator, 
        date=date,
        time=formatted_time,
        hide_estimate_form=True
    )

def credentials_to_dict(credentials):
    return {'token': credentials.token,
            'refresh_token': credentials.refresh_token,
            'token_uri': credentials.token_uri,
            'client_id': credentials.client_id,
            'client_secret': credentials.client_secret,
            'scopes': credentials.scopes}
            
@main.route('/generate_ics')
def generate_ics():
    estimator = request.args.get('estimator')
    location = request.args.get('location')
    date = request.args.get('date')
    time = request.args.get('time')

    event = icalendar.Event()
    event.add('summary', f'Appointment with {estimator}')
    event.add('dtstart', datetime.strptime(f'{date} {time}', '%Y-%m-%d %I:%M %p'))
    event.add('dtend', datetime.strptime(f'{date} {time}', '%Y-%m-%d %I:%M %p') + timedelta(hours=1))
    event.add('location', location)
    event.add('description', f'Your appointment at {location}')

    cal = icalendar.Calendar()
    cal.add_component(event)

    ics_content = cal.to_ical()

    response = Response(ics_content, mimetype='text/calendar')
    response.headers['Content-Disposition'] = 'attachment; filename=appointment.ics'
    return response

@main.route('/api/business_config', methods=['GET'])
@csrf.exempt
def get_business_config():
    try:
        configs = BusinessConfig.query.all()
        config_dict = {config.setting_name: config.setting_value for config in configs}
        # Ensure all required settings are included, with defaults
        response = {
            'company_timezone': config_dict.get('company_timezone', 'America/Denver'),
            'business_start_time': config_dict.get('business_start_time', '08:00'),
            'business_end_time': config_dict.get('business_end_time', '17:00'),
            'buffer_time_minutes': int(config_dict.get('buffer_time_minutes', 30))
        }
        current_app.logger.debug(f"Business config retrieved: {response}")
        return jsonify(response), 200
    except Exception as e:
        current_app.logger.error(f"Error fetching business config: {e}")
        return jsonify({'error': 'Failed to fetch business configuration'}), 500

C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\dbl.py:
from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from app import Config, create_app, db

app = create_app()

# db.init_app(app)  # This line is not necessary if db has been initialized in create_app

with app.app_context():
    #db.drop_all()
    db.create_all()


C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\modules\utils.py:
from PIL import Image
import io
from PIL import UnidentifiedImageError

def compress_image(image_path, quality=40, size=(1200, 1200), output_format=None):
    output = io.BytesIO()
    try:
        with Image.open(image_path) as img:
            if not output_format:
                output_format = img.format
            img.thumbnail(size)
            img.save(output, format=output_format, quality=quality)
            output.seek(0)
        return output
    except FileNotFoundError:
        print(f"File {image_path} not found.")
    except UnidentifiedImageError:
        print(f"Cannot identify image file {image_path}.")
    except Exception as e:
        print(f"Error compressing image: {e}")
    return None


C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\static\js\scriptv.js:
// static/js/script.js
console.log('Script version 1.2.3 loaded');


C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\static\js\appointment.js:
function createICSContent(appointment) {
    try {
        if (!appointment.preferred_date_time) {
            throw new Error('preferred_date_time is undefined');
        }

        const startDateTime = new Date(appointment.preferred_date_time);
        if (isNaN(startDateTime.getTime())) {
            throw new Error(`Invalid start date value: ${appointment.preferred_date_time}`);
        }

        const endDateTime = new Date(startDateTime.getTime() + 60 * 60000); // Assuming 1 hour appointments

        // Convert the dates to ISO strings without dashes, colons, and milliseconds
        const startISO = startDateTime.toISOString().replace(/-|:|\.\d\d\d/g, '');
        const endISO = endDateTime.toISOString().replace(/-|:|\.\d\d\d/g, '');

        const icsContent = [
            'BEGIN:VCALENDAR',
            'VERSION:2.0',
            'BEGIN:VEVENT',
            `DTSTART:${startISO}`,
            `DTEND:${endISO}`,
            `SUMMARY:${appointment.first_name} ${appointment.last_name}`,
            `DESCRIPTION:Appointment with ${appointment.first_name} ${appointment.last_name}. Service: ${appointment.service ? appointment.service : 'N/A'}.`,
            'END:VEVENT',
            'END:VCALENDAR'
        ].join('\n');

        return icsContent;
    } catch (error) {
        console.error('Error creating ICS content:', error, appointment);
        return '';
    }
}

function fetchAppointments() {
    fetch('api/admin_appointments', {
        credentials: 'include'  // Include cookies for session authentication
    })
    .then(response => {
        if (!response.ok) {
            console.error(`Server returned status ${response.status}`);
            throw new Error('Network response was not ok');
        }
        return response.json();
    })
    .then(data => {
        const appointmentsList = document.getElementById('appointmentsList');
        appointmentsList.innerHTML = ''; // Clear existing appointments
        data.forEach(appointment => {
            try {
                if (!appointment.preferred_date_time) {
                    console.warn('Skipping appointment due to missing preferred_date_time:', appointment);
                    return; // Skip this appointment
                }

                const dateTime = new Date(appointment.preferred_date_time);
                if (isNaN(dateTime.getTime())) {
                    throw new Error(`Invalid date value: ${appointment.preferred_date_time}`);
                }

                // Convert the dateTime to the user's local timezone
                const userTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
                const localDateTime = dateTime.toLocaleString('en-US', { timeZone: userTimezone });
                const formattedDateTime = new Date(localDateTime).toLocaleString('en-US', {
                    month: 'short',
                    day: '2-digit',
                    year: 'numeric',
                    hour: 'numeric',
                    minute: '2-digit',
                    hour12: true
                });

                const icsContent = createICSContent(appointment);
                const icsBlob = new Blob([icsContent], { type: 'text/calendar' });
                const icsUrl = URL.createObjectURL(icsBlob);

                const li = document.createElement('li');
                li.innerHTML = `<h3>${appointment.first_name} ${appointment.last_name}</h3> - 
                                <h4><a href="tel:${appointment.phone}">${appointment.phone}</a></h4> -
                                <h4>${appointment.email}</h4>
                                <h4><a href="${icsUrl}" download="${appointment.first_name}_${appointment.last_name}_appointment.ics">${formattedDateTime}</a></h4> - 
                                <h4>Service: ${appointment.service ? appointment.service : 'N/A'}</h4> - 
                                <h4>Estimator: ${appointment.estimator ? appointment.estimator : 'N/A'}</h4>
                                <button onclick="deleteAppointment(${appointment.id})">Delete</button>`;
                appointmentsList.appendChild(li);
            } catch (error) {
                console.error('Error processing appointment:', error, appointment);
            }
        });
    })
    .catch(error => {
        console.error('Fetch error:', error);
    });
}

function deleteAppointment(appointmentId) {
    const csrfToken = document.querySelector('meta[name="csrf-token"]').getAttribute('content');
    fetch(`api/appointments/delete`, {
        method: 'POST',
        credentials: 'include',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': csrfToken
        },
        body: JSON.stringify({ appointment_id: appointmentId })
    })
    .then(response => {
        if (!response.ok) {
            console.error(`Server returned status ${response.status}`);
            throw new Error('Network response was not ok');
        }
        return response.json();
    })
    .then(data => {
        if (data.status === 'success') {
            fetchAppointments(); // Refresh the appointments list
        } else {
            console.error('Error deleting appointment:', data.message);
        }
    })
    .catch(error => {
        console.error('Fetch error:', error);
    });
}

// Fetch appointments every minute
setInterval(fetchAppointments, 60000);
fetchAppointments(); // Initial fetch

C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\modules\locations.py:
def get_locations():
    # Define your locations as a list of dictionaries in Python
    locations = [
        {'lat': 43.6187, 'lng': -116.2146, 'title': 'Boise, Idaho'},
        {'lat': 43.6162, 'lng': -116.4415, 'title': 'Meridian, Idaho'},
        {'lat': 43.6918, 'lng': -116.4135, 'title': 'Eagle, Idaho'},
        {'lat': 43.7190, 'lng': -116.2686, 'title': 'Hidden Springs, Idaho'},
        {'lat': 43.4955, 'lng': -116.4576, 'title': 'Kuna, Idaho'},
        {'lat': 43.5861, 'lng': -116.6452, 'title': 'Nampa, Idaho'},
        {'lat': 43.6394, 'lng': -116.7355, 'title': 'Caldwell, Idaho'},
        {'lat': 43.7276, 'lng': -116.8092, 'title': 'Notus, Idaho'},
        {'lat': 43.7844, 'lng': -116.9614, 'title': 'Parma, Idaho'},
        {'lat': 43.6749, 'lng': -116.9142, 'title': 'Wilder, Idaho'},
        {'lat': 43.6175, 'lng': -116.9461, 'title': 'Homedale, Idaho'},
        {'lat': 43.5481, 'lng': -116.8143, 'title': 'Marsing, Idaho'},
        {'lat': 43.9696, 'lng': -116.8279, 'title': 'New Plymouth, Idaho'},
        {'lat': 44.0200, 'lng': -116.9410, 'title': 'Fruitland, Idaho'},
        {'lat': 44.0773, 'lng': -116.9471, 'title': 'Payette, Idaho'},
        {'lat': 44.2628, 'lng': -116.9887, 'title': 'Weiser, Idaho'},
        {'lat': 44.0313, 'lng': -116.9983, 'title': 'Ontario, Oregon'},
        {'lat': 43.7408, 'lng': -117.0757, 'title': 'Adrian, Oregon'},
        {'lat': 43.8819, 'lng': -117.0082, 'title': 'Nyssa, Oregon'},
        {'lat': 44.9002, 'lng': -116.1557, 'title': 'McCall, Idaho'},
        {'lat': 44.9701, 'lng': -116.2937, 'title': 'New Meadows, Idaho'},
        {'lat': 44.7287, 'lng': -116.0828, 'title': 'Donnelly, Idaho'},
        {'lat': 38.4765, 'lng': -119.6625, 'title': 'Nevada'},
        {'lat': 36.1251, 'lng': -115.3398, 'title': 'Las Vegas, Nevada'},
        {'lat': 45.3804, 'lng': -119.4239, 'title': 'Idaho'},
        {'lat': 44.1191, 'lng': -123.2225, 'title': 'Oregon'},
        {'lat': 39.4740, 'lng': -114.1867, 'title': 'Utah'}
    ]
    return locations

C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\extensions.py:
# app/extensions.py
from flask_login import LoginManager
from flask_wtf.csrf import CSRFProtect, generate_csrf
from flask_mail import Mail
from flask_bcrypt import Bcrypt

login_manager = LoginManager()
csrf = CSRFProtect()
mail = Mail()
bcrypt = Bcrypt()


C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\static\js\slideout-menu.js:
document.addEventListener('DOMContentLoaded', function() {
    const menuIcon = document.getElementById('menu-icon');
    const slideoutMenu = document.getElementById('slideout-menu');
    const header = document.querySelector('.modern-header');

    // Toggle slideout menu
    menuIcon.addEventListener('click', function() {
        slideoutMenu.classList.toggle('active');
        menuIcon.classList.toggle('active'); // Rotate the hamburger icon
    });

    // Add 'scrolled' class to header on scroll
    window.addEventListener('scroll', function() {
        if (window.scrollY > 50) { // Adjust this value based on your header height
            header.classList.add('scrolled');
        } else {
            header.classList.remove('scrolled');
        }
    });
});

C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\.gitignore:
env/
*.pyc
*.pyc
.pyc
*.psd
/instance
/migrations
/env



C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\directory_ai.py:
import os
import concurrent.futures
import threading
import logging
from pathlib import Path
from typing import List, Optional, Set

# Configure logging for better debugging
logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

def is_ignored_path(path: str, ignore_dirs: Set[str], ignore_extensions: Set[str]) -> bool:
    """
    Check if a path should be ignored based on directory names or file extensions.
    
    Args:
        path: The file or directory path to check
        ignore_dirs: Set of directory names to ignore
        ignore_extensions: Set of file extensions to ignore (including dot, e.g., '.txt')
    
    Returns:
        bool: True if the path should be ignored
    """
    path_obj = Path(path)
    
    # Check if any directory in the path matches ignore_dirs
    if any(part in ignore_dirs for part in path_obj.parts):
        logger.debug(f"Ignoring path {path} due to directory match")
        return True
    
    # Check file extension
    if path_obj.suffix.lower() in ignore_extensions:
        logger.debug(f"Ignoring path {path} due to extension {path_obj.suffix}")
        return True
    
    logger.debug(f"Path {path} is not ignored")
    return False

def process_file(root: str, file: str, ignore_dirs: Set[str], ignore_extensions: Set[str]) -> Optional[List[str]]:
    """
    Process a single file and return its contents with metadata.
    
    Args:
        root: Directory path containing the file
        file: Name of the file to process
        ignore_dirs: Set of directories to ignore
        ignore_extensions: Set of file extensions to ignore
    
    Returns:
        Optional[List[str]]: File contents with metadata or None if ignored
    """
    file_path = os.path.join(root, file)
    
    if is_ignored_path(file_path, ignore_dirs, ignore_extensions):
        logger.debug(f"Skipping ignored file: {file_path}")
        return None

    content_lines = [f"{file_path}:\n"]
    logger.debug(f"Processing file: {file_path}")
    try:
        # Only process text files smaller than 10MB
        if os.path.getsize(file_path) > 10 * 1024 * 1024:
            content_lines.append("<File too large to process>\n")
            logger.debug(f"File too large: {file_path}")
            return content_lines
            
        with open(file_path, 'r', encoding='utf-8', errors='ignore') as content_file:
            content = content_file.read()
            content_lines.append(content)
            logger.debug(f"Successfully read file: {file_path}")
    except UnicodeDecodeError:
        content_lines.append("<Binary file or unsupported encoding>\n")
        logger.debug(f"Binary or unsupported encoding: {file_path}")
    except PermissionError:
        content_lines.append("<Permission denied>\n")
        logger.debug(f"Permission denied: {file_path}")
    except Exception as e:
        logger.error(f"Error processing {file_path}: {str(e)}")
        content_lines.append(f"<Error reading file: {e}>\n")
    
    content_lines.append("\n\n")
    return content_lines

def build_directory_contents(startpath: str, output_file: str, 
                           ignore_dirs: Set[str], ignore_extensions: Set[str]) -> None:
    """
    Build directory contents and write to output file using concurrent processing.
    
    Args:
        startpath: Root directory to start scanning
        output_file: Output file path
        ignore_dirs: Set of directories to ignore
        ignore_extensions: Set of file extensions to ignore
    """
    # Validate input path
    start_path = Path(startpath)
    if not start_path.exists() or not start_path.is_dir():
        raise ValueError(f"Invalid or non-existent directory: {startpath}")
    
    # Validate output file path
    output_path = Path(output_file)
    try:
        output_path.parent.mkdir(parents=True, exist_ok=True)
    except Exception as e:
        raise ValueError(f"Cannot create output directory: {str(e)}")

    # Use a lock for thread-safe list operations
    contents_lock = threading.Lock()
    contents: List[str] = []
    
    # Optimize number of workers based on CPU count
    num_workers = max(1, min(os.cpu_count() * 2, 32))  # Cap at 32 to prevent resource exhaustion
    
    logger.info(f"Starting directory scan with {num_workers} workers")
    
    with concurrent.futures.ThreadPoolExecutor(max_workers=num_workers) as executor:
        future_to_file = {}
        for root, dirs, files in os.walk(startpath, topdown=True):
            # Log directories being scanned
            logger.debug(f"Scanning directory: {root}")
            # Modify dirs in-place to skip ignored directories
            dirs[:] = [d for d in dirs if d not in ignore_dirs]
            logger.debug(f"Directories after filtering: {dirs}")
            for file in files:
                future_to_file[executor.submit(process_file, root, file, ignore_dirs, ignore_extensions)] = file
        
        for future in concurrent.futures.as_completed(future_to_file):
            try:
                file_content = future.result()
                if file_content:
                    with contents_lock:
                        contents.extend(file_content)
                        logger.debug(f"Added content from file, current content length: {len(contents)}")
            except Exception as e:
                logger.error(f"Error processing future: {str(e)}")

    # Log contents before writing
    logger.debug(f"Total content lines to write: {len(contents)}")
    
    # Write results to output file
    try:
        with open(output_file, 'w', encoding='utf-8') as out:
            out.writelines(contents)
        logger.info(f"Successfully wrote contents to {output_file}")
    except Exception as e:
        logger.error(f"Error writing to output file: {str(e)}")
        raise

def main():
    """Main function to execute the directory contents builder."""
    code_repository_path = 'C:\\Users\\zimme\\OneDrive\\Documents\\GitHub\\flask-template-repo'
    output_file = 'output_main.txt'
    
    # Separate directory names and file extensions
    ignore_dirs = {
        'env', 'images', 'fonts', 'docs', '__pycache__', 'instance', 
        'tests', 'migrations', 'flask_stripe', '.git', 'fullcalendar',
    }
    ignore_extensions = {
        '.txt', '.css', '.gitattributes', '.md', '.pyc', '.html'
    }
    
    try:
        build_directory_contents(code_repository_path, output_file, ignore_dirs, ignore_extensions)
        print(f"Directory contents have been written to {output_file}")
    except Exception as e:
        logger.error(f"Failed to build directory contents: {str(e)}")
        print(f"Error: {str(e)}")

if __name__ == '__main__':
    main()

C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\.slugignore:
# Ignore virtual environment directory
env/

# Ignore Python bytecode files
*.pyc

# Ignore Photoshop files
*.psd

# Ignore instance directory
/instance

# Ignore migrations directory
/migrations

# Ignore virtual environment directory (redundant entry removed)
/env


C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\static\js\slider.js:
var slideIndex = 1;
showSlides(slideIndex);

// Next/previous controls
function moveSlide(n) {
  showSlides(slideIndex += n);
}

// Thumbnail image controls
function currentSlide(n) {
showSlides(slideIndex = n);
}

function showSlides(n) {
  var i;
  var slides = document.getElementsByClassName("carousel-slide");
  var dots = document.getElementsByClassName("dot");

  if (n > slides.length) {slideIndex = 1}
  if (n < 1) {slideIndex = slides.length}

  // Hide all slides
  for (i = 0; i < slides.length; i++) {
    slides[i].style.display = "none";  
  }

  // Remove the "active" class from all dots
  for (i = 0; i < dots.length; i++) {
    dots[i].className = dots[i].className.replace(" active", "");
  }

  // Show the current slide and add "active" class to the corresponding dot
  slides[slideIndex-1].style.display = "block";  
  dots[slideIndex-1].className += " active";
}

document.querySelector('.hero-carousel').addEventListener('touchmove', function(e) {
  // Determine swipe direction
  var touch = e.touches[0];
  var change = touch.clientX - touchStartX; // touchStartX is where the swipe started
  var isHorizontalSwipe = Math.abs(change) > Math.abs(touch.clientY - touchStartY);

  // Prevent vertical scrolling if it's a horizontal swipe
  if (isHorizontalSwipe) {
      e.preventDefault();
  }
}, { passive: false });


// Optional: Add auto-slide functionality
var slideInterval = setInterval(function() { moveSlide(1); }, 3000); // Change image every 3 seconds


C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\modules\role_setup.py:
# ideal-sniffle/app/modules/role_setup.py

from app.models import Role
from app.database import db

def create_roles():
    """Create default roles."""
    roles = ['admin', 'user', 'blogger', 'commercial']  # Add other roles as needed
    for name in roles:
        if not Role.query.filter_by(name=name).first():
            new_role = Role(name=name)
            db.session.add(new_role)
    db.session.commit()



C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\modules\auth_manager.py:
# app/modules/auth_manager.py
"""Authentication and role-based access control utilities for the Flask application.

This module provides functions and decorators for managing user authentication
and restricting access to routes based on user roles, integrating with Flask-Login
and the User model. It includes decorators for admin and blogger roles, ensuring
secure access control aligned with OWASP guidelines.
"""

from flask import flash, redirect, url_for
from flask_login import UserMixin, LoginManager, current_user
from functools import wraps
from app.database import db
from app.models import User
from app import login_manager, current_app

@login_manager.user_loader
def load_user(user_id):
    """Load a user from the database by ID for Flask-Login.

    Args:
        user_id (str): The ID of the user to load.

    Returns:
        User: The User object, or None if not found.
    """
    return User.query.get(int(user_id))

def admin_required(f):
    """Decorator to restrict access to routes for admin users only.

    Redirects unauthenticated or non-admin users to the login page with a warning.

    Args:
        f (function): The view function to decorate.

    Returns:
        function: The decorated function.
    """
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not current_user.is_authenticated or not current_user.has_role('admin'):
            current_app.logger.warning(
                f"Unauthorized access attempt to admin route by user: {current_user.username if current_user.is_authenticated else 'anonymous'}"
            )
            flash('You do not have permission to view this page.', 'warning')
            return redirect(url_for('auth.login'))
        return f(*args, **kwargs)
    return decorated_function

def blogger_required(f):
    """Decorator to restrict access to routes for blogger users only.

    Redirects unauthenticated or non-blogger users to the login page with a warning.

    Args:
        f (function): The view function to decorate.

    Returns:
        function: The decorated function.
    """
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not current_user.is_authenticated or not current_user.has_role('blogger'):
            current_app.logger.warning(
                f"Unauthorized access attempt to blogger route by user: {current_user.username if current_user.is_authenticated else 'anonymous'}"
            )
            flash('You do not have permission to view this page.', 'warning')
            return redirect(url_for('auth.login'))
        return f(*args, **kwargs)
    return decorated_function

C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\modules\__init__.py:


C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\static\js\mutator.js:
document.addEventListener("DOMContentLoaded", function() {
    // Target container where you want the widget to be placed
    const targetContainer = document.getElementById('square-appointments-widget');

    // Options for the observer (which mutations to observe)
    const config = { childList: true, subtree: true };

    // Callback function to execute when mutations are observed
    const callback = function(mutationsList, observer) {
        for(let mutation of mutationsList) {
            if (mutation.type === 'childList') {
                // Check if the Square widget has been added
                const squareWidget = document.querySelector('.square-appointments-widget'); // Adjust the selector based on the actual widget's class or ID
                if (squareWidget) {
                    // Move the widget to the target container
                    targetContainer.appendChild(squareWidget);
                    observer.disconnect(); // Stop observing once the widget has been moved
                }
            }
        }
    };

    // Create an observer instance linked to the callback function
    const observer = new MutationObserver(callback);

    // Start observing the document body for configured mutations
    observer.observe(document.body, config);
});

C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\modules\indexing.py:
from flask import Flask, render_template, url_for, request, redirect, Response
import xml.etree.ElementTree as ET
import os
import requests
from app import create_app

# Sitemap generation function (to be modified as per your requirements)
def generate_sitemap(app):
    app = create_app()  # Create an instance of the Flask app
    with app.app_context():
        # Extract routes from the application
        links = []
        for rule in app.url_map.iter_rules():
            # Filter out rules you can't navigate to in a browser
            # and rules that require parameters
            if "GET" in rule.methods and len(rule.arguments) == 0:
                url = url_for(rule.endpoint, _external=True)
                links.append(url)

        # Generate sitemap
        urlset = ET.Element("urlset", xmlns="http://www.sitemaps.org/schemas/sitemap/0.9")
        for link in links:
            u = ET.SubElement(urlset, "url")
            loc = ET.SubElement(u, "loc")
            loc.text = link

        tree = ET.ElementTree(urlset)
        sitemap_path = os.path.join(app.static_folder, 'sitemap.xml')
        tree.write(sitemap_path, encoding='utf-8', xml_declaration=True)

    # Submit to Bing
    submit_sitemap_to_bing('http://www.znhhomebuilders.com/static/sitemap.xml')

def submit_sitemap_to_bing(sitemap_url):
    api_key = 'f00ed402512c4d4b929fec116ad623d3'  # Store this in a secure place
    submit_url = f'https://www.bing.com/indexnow?url={sitemap_url}&key={api_key}'
    response = requests.get(submit_url)
    if response.status_code == 200:
        print("Sitemap successfully submitted to Bing")
    else:
        print("Error submitting sitemap to Bing:", response.text)

def check_and_submit_new_page(page):
    if page.is_public:  # Check if the page is not login restricted
        submit_sitemap_to_bing(page.url)

C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\routes\auth.py:
from flask import Blueprint, render_template, redirect, url_for, flash, request, session
from flask_login import login_user, logout_user
from flask_mail import Message
from flask import current_app as app
# Assuming the below modules are part of your application
from app import db, mail, bcrypt  # Adjust 'yourapp' to your actual app's name
from app.models import User, Role  # Adjust 'yourapp.models' to your actual models' location
from app.forms import RegistrationForm, LoginForm, EstimateRequestForm  # Adjust 'yourapp.forms' to your actual forms' location

auth = Blueprint('auth', __name__)

@auth.context_processor
def combined_context_processor():
    erf_form = EstimateRequestForm()
    return dict(erf_form=erf_form)

@auth.route("/register", methods=['GET', 'POST'])
def register():
    form = RegistrationForm()
    form.role.choices = [(role.id, role.name) for role in Role.query.filter(Role.name != 'admin').all()]

    if form.validate_on_submit():
        if not form.accept_tos.data:
            flash('You must agree to the Terms and Conditions to register.', 'warning')
            return render_template('register.html', title='Register', form=form)

        # Refactor user existence checks into a function
        if user_exists(form.email.data, form.username.data):
            return render_template('register.html', title='Register', form=form)

        # Create and add the new user
        new_user = create_new_user(form)
        db.session.add(new_user)
        db.session.commit()
        login_user(new_user)

        # Handle post-registration redirection
        return handle_post_registration_redirect()

    return render_template('register.html', title='Register', form=form)

def user_exists(email, username):
    """Check if a user with the given email or username already exists."""
    if User.query.filter_by(email=email).first():
        flash('An account with this email already exists.', 'warning')
        return True
    if User.query.filter_by(username=username).first():
        flash('This username is already taken. Please choose a different one.', 'warning')
        return True
    return False

def create_new_user(form):
    """Create a new user instance from the registration form."""
    new_user = User(username=form.username.data, email=form.email.data, password=form.password.data)
    new_user.first_name = form.first_name.data
    new_user.last_name = form.last_name.data
    role = Role.query.get(form.role.data)
    if role:
        new_user.roles.append(role)
    return new_user

def handle_post_registration_redirect():
    """Handle redirection after successful registration."""
    if 'booking_address' in session:
        flash('Account created! Please continue with your booking.', 'success')
        return redirect(url_for('user.manage_booking'))
    else:
        flash('Your account has been created! You are now logged in.', 'success')
        return redirect(url_for('main_routes.index'))

@auth.route("/login", methods=['GET', 'POST'])
def login():
    form = LoginForm()
    if form.validate_on_submit():
        # Normalize email to lowercase
        email = form.email.data.lower()
        user = User.query.filter_by(email=email).first()

        if user:
            if bcrypt.check_password_hash(user.password_hash, form.password.data):
                login_user(user)
                app.logger.info(f'User logged in: {user.username}')  # Logging successful login
                
                if not user.tos_accepted:
                    # Redirect to accept terms if not already accepted
                    return redirect(url_for('main_routes.accept_terms'))
                
                flash('You have been logged in!', 'success')
                next_page = request.args.get('next')
                return redirect(next_page) if next_page else redirect(url_for('main_routes.index'))
            else:
                # Log failed password check
                app.logger.warning(f'Failed login attempt for {email}: Incorrect password')
        else:
            # Log failed login attempt due to user not found
            app.logger.warning(f'Failed login attempt for {email}: User not found')

        flash('Login Unsuccessful. Please check email and password', 'danger')

    # Log form validation errors
    if form.errors:
        app.logger.warning(f'Login form validation errors: {form.errors}')

    return render_template('login.html', title='Login', form=form)

@auth.route("/logout")
def logout():
    # Clear the entire session when the user logs out
    session.clear()
    logout_user()
    return redirect(url_for('auth.login'))

@auth.route('/forgot_password', methods=['POST'])
def forgot_password():
    email = request.form.get('email')
    user = User.query.filter_by(email=email).first()
    if user:
        token = user.generate_reset_token()
        msg = Message("Password reset request",
                      sender="noreply@demo.com",
                      recipients=[user.email])
        msg.body = f"""To reset your password, visit the following link:
{url_for('main.reset_password', token=token, _external=True)}

If you did not make this request then simply ignore this email and no changes will be made.
"""
        mail.send(msg)
        return "Password reset email sent!"
    else:
        return "Invalid email"

@auth.route('/reset_password', methods=['POST'])
def reset_password():
    token = request.form.get('token')
    password = request.form.get('password')
    user = User.verify_reset_token(token)
    if user:
        # Hash the new password with bcrypt
        hashed_password = bcrypt.generate_password_hash(password).decode('utf-8')
        user.set_password(hashed_password)  # Assuming set_password is properly adjusted to use bcrypt
        db.session.commit()
        flash('Your password has been updated!', 'success')
        return redirect(url_for('auth.login'))
    else:
        flash('That is an invalid or expired token', 'warning')
        return redirect(url_for('main.register'))


C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\.env:
FLASK_APP=app
SECRET_KEY=2894565132464132168746541065496
FLASK_ENV=development

C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\run.py:
from app import create_app  # You'll create a create_app function in __init__.py

app = create_app()

if __name__ == '__main__':
    app.run(debug=True)


C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\__init__.py:
from flask import Flask, current_app, url_for
from flask_sqlalchemy import SQLAlchemy
from flask_login import LoginManager
from flask_wtf.csrf import CSRFProtect, generate_csrf
from flask_mail import Mail
from flask_bcrypt import Bcrypt
from flask_migrate import Migrate
from flask.cli import with_appcontext, AppGroup
from flask_caching import Cache
from app.config import Config
from app.modules.role_setup import create_roles
from app.database import db
from app.models import User, Role, BusinessConfig
from dotenv import load_dotenv
import os
import logging
import click
import pytz
from datetime import datetime
from flask_ckeditor import CKEditor

# Load environment variables
load_dotenv()

# Initialize extensions
login_manager = LoginManager()
csrf = CSRFProtect()
mail = Mail()
bcrypt = Bcrypt()
migrate = Migrate()
ckeditor = CKEditor()

# CLI group for debugging
debug_cli = AppGroup('debug')

@debug_cli.command('print-env')
def print_env():
    """Print environment variables for debugging."""
    print(f"FLASK_ENV: {os.environ.get('FLASK_ENV')}")
    print(f"SECRET_KEY: {os.environ.get('SECRET_KEY')}")
    print(f"DATABASE_URL: {current_app.config['SQLALCHEMY_DATABASE_URI']}")

# CLI command to create roles
@click.command('create-roles')
@with_appcontext
def create_roles_command():
    """Create default user roles."""
    create_roles()
    click.echo('Default roles have been created.')

@click.command('seed-business-config')
@with_appcontext
def seed_business_config_command():
    """Seed default business configuration."""
    default_configs = [
        {'setting_name': 'business_start_time', 'setting_value': '08:00'},
        {'setting_name': 'business_end_time', 'setting_value': '17:00'},
        {'setting_name': 'buffer_time_minutes', 'setting_value': '30'},
        {'setting_name': 'company_timezone', 'setting_value': 'America/Denver'}
    ]
    for config in default_configs:
        if not BusinessConfig.query.filter_by(setting_name=config['setting_name']).first():
            new_config = BusinessConfig(**config)
            db.session.add(new_config)
    db.session.commit()
    click.echo('Default business configuration seeded.')

# Application factory
def create_app(config_class=Config):
    app = Flask(__name__)

    # Configure logging
    logging.basicConfig(level=logging.DEBUG)
    app.logger.setLevel(logging.DEBUG)
    handler = logging.StreamHandler()
    handler.setLevel(logging.DEBUG)
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    handler.setFormatter(formatter)
    app.logger.addHandler(handler)

    # Load configuration
    app.config.from_object(config_class)
    app.config['SECRET_KEY'] = os.getenv('SECRET_KEY')
    app.config['SQLALCHEMY_DATABASE_URI'] = os.environ.get('DATABASE_URL', 'sqlite:///default.db').replace('postgres://', 'postgresql://', 1)
    app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
    app.config['SCHEDULER_API_ENABLED'] = True

    # Mail configuration from environment variables
    app.config['MAIL_SERVER'] = os.getenv('MAIL_SERVER', 'smtp.example.com')
    app.config['MAIL_PORT'] = int(os.getenv('MAIL_PORT', 587))
    app.config['MAIL_USE_TLS'] = os.getenv('MAIL_USE_TLS', 'True').lower() == 'true'
    app.config['MAIL_USERNAME'] = os.getenv('MAIL_USERNAME')
    app.config['MAIL_PASSWORD'] = os.getenv('MAIL_PASSWORD')
    app.config['MAIL_DEFAULT_SENDER'] = os.getenv('MAIL_DEFAULT_SENDER')

    # SQLAlchemy connection pooling options
    app.config['SQLALCHEMY_ENGINE_OPTIONS'] = {
        "pool_pre_ping": True,
        "pool_recycle": 300,
    }

    # Register CLI commands
    app.cli.add_command(create_roles_command)
    app.cli.add_command(debug_cli)
    app.cli.add_command(seed_business_config_command)

    # CLI command to set admin role
    @app.cli.command('set-admin')
    @click.argument('email')
    def set_admin(email):
        """Set a user as admin by email."""
        user = User.query.filter_by(email=email).first()
        if user:
            admin_role = Role.query.filter_by(name='admin').first()
            if admin_role not in user.roles:
                user.roles.append(admin_role)
                db.session.commit()
                print(f"User {email} set as admin.")
            else:
                print("User already has admin role.")
        else:
            print("User not found.")

    # Initialize extensions
    db.init_app(app)
    csrf.init_app(app)
    migrate.init_app(app, db)
    bcrypt.init_app(app)
    login_manager.login_view = 'auth.login'
    login_manager.init_app(app)
    mail.init_app(app)
    ckeditor = CKEditor(app)
    

    # User loader for Flask-Login
    @login_manager.user_loader
    def load_user(user_id):
        return User.query.get(int(user_id))

    # Inject CSRF token into templates
    @app.context_processor
    def inject_csrf_token():
        return dict(csrf_token=generate_csrf())

    # Override url_for to add version to static files
    @app.context_processor
    def override_url_for():
        return dict(url_for=dated_url_for)

    def dated_url_for(endpoint, **values):
        if endpoint == 'static':
            filename = values.get('filename')
            if filename:
                values['v'] = '1.0.0'  # Update this version manually as needed
        return url_for(endpoint, **values)

    # Register blueprints
    from app.routes.auth import auth
    from app.routes.main_routes import main
    from app.routes.user import user
    from app.routes.admin import admin as admin_blueprint
    from app.routes.blog import blog_blueprint, news_update, updates_blueprint

    app.register_blueprint(auth)
    app.register_blueprint(main)
    app.register_blueprint(user)
    app.register_blueprint(admin_blueprint, url_prefix='/admin')
    app.register_blueprint(blog_blueprint)
    app.register_blueprint(news_update)
    app.register_blueprint(updates_blueprint)

    return app

# Instantiate app for CLI and direct execution
app = create_app()

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=int(os.environ.get('PORT', 5000)))

C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\modules\file_manager.py:
# Standard library imports
import csv
import os

# Third-party imports
from flask import abort, g, make_response, send_file, current_user
from flask_login import login_required
import json

# Local application imports
from app.models import Campaign
import app

# For a given file, return whether it's an allowed type or not
def allowed_file(filename):
    return '.' in filename and \
           filename.rsplit('.', 1)[1] in app.config['ALLOWED_EXTENSIONS']

# Utility Functions
def load_json(file_path):
    with open(file_path, 'r') as f:
        return json.load(f)

# For a given file, return whether it's an allowed type or not
def allowed_file(filename):
    return '.' in filename and \
           filename.rsplit('.', 1)[1] in app.config['ALLOWED_EXTENSIONS']

@app.after_request
def delete_file(response):
    filename = getattr(g, 'filename', None)
    if filename:
        try:
            os.remove(filename)
        except Exception as error:
            app.logger.error("Error removing or closing downloaded file handle", error)
    return response
        

C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\routes\blog.py:
from flask import Blueprint, render_template, redirect, url_for, flash, request, jsonify, Response
from flask_login import login_required, current_user
from flask import current_app as app
from app import db, mail, bcrypt
from app.models import User, Role, Post
from app.forms import RegistrationForm, LoginForm, EstimateRequestForm, CreatePostForm, EditPostForm, CSRFTokenForm
from app.modules.auth_manager import blogger_required
from sqlalchemy.exc import IntegrityError, SQLAlchemyError
import logging
import io
import bleach

# Allowed HTML tags and attributes for sanitization
ALLOWED_TAGS = [
    'p', 'br', 'strong', 'em', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
    'ul', 'ol', 'li', 'a', 'img', 'blockquote', 'code', 'pre'
]
ALLOWED_ATTRIBUTES = {
    'a': ['href', 'title'],
    'img': ['src', 'alt']
}

# Configure logging
logger = logging.getLogger(__name__)

blog_blueprint = Blueprint('blog', __name__, template_folder='templates/')
news_update = Blueprint('news', __name__, template_folder='templates/')
updates_blueprint = Blueprint('updates', __name__, template_folder='templates')

# Context processors for consistent form inclusion
@blog_blueprint.context_processor
def combined_context_processor():
    erf_form = EstimateRequestForm()
    return dict(erf_form=erf_form, hide_estimate_form=True)

@news_update.context_processor
def combined_context_processor():
    erf_form = EstimateRequestForm()
    return dict(erf_form=erf_form, hide_estimate_form=True)

@updates_blueprint.context_processor
def combined_context_processor():
    erf_form = EstimateRequestForm()
    return dict(erf_form=erf_form, hide_estimate_form=True)

# Serve post image
@blog_blueprint.route('/blog/image/<int:post_id>')
def serve_image(post_id):
    """Serve the image for a blog post."""
    try:
        post = Post.query.get_or_404(post_id)
        if not post.image or not post.image_mime_type:
            logger.debug(f"No image found for post ID {post_id}")
            return Response(status=404)
        logger.debug(f"Serving image for post ID {post_id}")
        return Response(post.image, mimetype=post.image_mime_type)
    except Exception as e:
        logger.error(f"Error serving image for post ID {post_id}: {e}")
        return Response(status=500)

# Public blog list route
@blog_blueprint.route('/blog')
def show_blog():
    """Display a paginated list of published blog posts."""
    try:
        page = request.args.get('page', 1, type=int)
        per_page = 10
        posts = Post.query.filter_by(is_published=True).order_by(Post.created_at.desc()).paginate(page=page, per_page=per_page, error_out=False)
        logger.debug(f"Retrieved {posts.total} published posts for page {page}")
        return render_template('blog/blog.html', posts=posts)
    except Exception as e:
        logger.error(f"Error fetching blog posts: {e}")
        flash('An error occurred while loading the blog.', 'danger')
        return render_template('blog/blog.html', posts=None)

# Individual blog post route
@blog_blueprint.route('/blog/<string:slug>')
def show_post(slug):
    """Display an individual blog post by slug."""
    try:
        post = Post.query.filter_by(slug=slug, is_published=True).first_or_404()
        logger.debug(f"Retrieved post with slug: {slug}")
        return render_template('blog/post.html', post=post)
    except Exception as e:
        logger.error(f"Error fetching post with slug {slug}: {e}")
        flash('The requested post could not be found.', 'danger')
        return render_template('errors/404.html'), 404

# Blog management dashboard (blogger role required)
@blog_blueprint.route('/blog/manage')
@login_required
@blogger_required
def manage_posts():
    """Display a paginated list of all posts for management."""
    try:
        page = request.args.get('page', 1, type=int)
        per_page = 10
        # Show all posts for the current user or admins
        if current_user.has_role('admin'):
            posts = Post.query.order_by(Post.created_at.desc()).paginate(page=page, per_page=per_page, error_out=False)
        else:
            posts = Post.query.filter_by(author_id=current_user.id).order_by(Post.created_at.desc()).paginate(page=page, per_page=per_page, error_out=False)
        form = CSRFTokenForm()
        logger.debug(f"Retrieved {posts.total} posts for management by user {current_user.username}")
        return render_template('blog/manage_posts.html', posts=posts, form=form)
    except Exception as e:
        logger.error(f"Error fetching posts for management: {e}")
        flash('An error occurred while loading your posts.', 'danger')
        return render_template('blog/manage_posts.html', posts=None, form=CSRFTokenForm())

# Create new post (blogger role required)
@blog_blueprint.route('/blog/new', methods=['GET', 'POST'])
@login_required
@blogger_required
def new_post():
    form = CreatePostForm()
    if form.validate_on_submit():
        try:
            # Initialize image fields
            image_data = None
            image_mime_type = None
            if form.image.data:
                # Reset file pointer to ensure the stream is readable
                form.image.data.seek(0)
                image_data = form.image.data.read()
                image_mime_type = form.image.data.mimetype
            # Sanitize the content
            sanitized_content = bleach.clean(
                form.content.data,
                tags=ALLOWED_TAGS,
                attributes=ALLOWED_ATTRIBUTES,
                strip=True
            )
            post = Post(
                title=form.title.data,
                content=sanitized_content,
                category=form.category.data,
                is_published=form.is_published.data,
                author_id=current_user.id,
                slug=form.title.data.lower().replace(' ', '-'),
                image=image_data,
                image_mime_type=image_mime_type
            )
            db.session.add(post)
            db.session.commit()
            logger.info(f"New post created by {current_user.username}: {post.title}")
            flash('Post created successfully.', 'success')
            return redirect(url_for('blog.manage_posts'))
        except IntegrityError:
            db.session.rollback()
            logger.error(f"Duplicate slug detected for post: {form.title.data}")
            flash('A post with this title already exists. Please choose a different title.', 'danger')
        except SQLAlchemyError as e:
            db.session.rollback()
            logger.error(f"Database error creating post: {e}")
            flash('An error occurred while creating the post.', 'danger')
    if form.errors:
        logger.debug(f"Form validation errors: {form.errors}")
    return render_template('blog/new_post.html', form=form)

@blog_blueprint.route('/blog/edit/<int:post_id>', methods=['GET', 'POST'])
@login_required
@blogger_required
def edit_post(post_id):
    post = Post.query.get_or_404(post_id)
    if post.author_id != current_user.id and not current_user.has_role('admin'):
        logger.warning(f"Unauthorized edit attempt by {current_user.username} on post ID {post_id}")
        flash('You are not authorized to edit this post.', 'danger')
        return render_template('errors/403.html'), 403
    form = EditPostForm(obj=post)
    if form.validate_on_submit():
        try:
            post.title = form.title.data
            # Sanitize the content
            post.content = bleach.clean(
                form.content.data,
                tags=ALLOWED_TAGS,
                attributes=ALLOWED_ATTRIBUTES,
                strip=True
            )
            post.category = form.category.data
            post.is_published = form.is_published.data
            post.slug = form.title.data.lower().replace(' ', '-')
            if form.image.data:
                post.image = form.image.data.read()
                post.image_mime_type = form.image.data.mimetype
            db.session.commit()
            logger.info(f'"{post.title}" updated successfully by {current_user.username}')
            flash('Record updated successfully.', 'success')
            return redirect(url_for('blog.manage_posts'))
        except IntegrityError:
            db.session.rollback()
            logger.error(f"Duplicate slug detected for post ID {post_id}")
            flash('A post with this title already exists. Please choose a different title.', 'danger')
        except SQLAlchemyError as e:
            db.session.rollback()
            logger.error(f"Error updating post ID {post_id}: {e}")
            flash('Error updating record. Please try again.', 'error')
    elif request.method == 'POST':
        logger.debug(f"Form validation failed: {form.errors}")
    return render_template('blog/edit.html', form=form, post=post, id=post_id)

# Delete post (blogger role required)
@blog_blueprint.route('/blog/delete/<int:id>', methods=['POST'])
@login_required
@blogger_required
def delete_post(id):
    """Delete a blog post by ID."""
    post = Post.query.get_or_404(id)
    # Restrict access to post author or admins
    if post.author_id != current_user.id and not current_user.has_role('admin'):
        logger.warning(f"Unauthorized delete attempt by {current_user.username} on post ID {id}")
        flash('You are not authorized to delete this post.', 'danger')
        return render_template('errors/403.html'), 403
    
    csrf_form = CSRFTokenForm()
    if csrf_form.validate_on_submit():
        try:
            db.session.delete(post)
            db.session.commit()
            logger.info(f"Post ID {id} deleted by {current_user.username}")
            flash('Post deleted successfully.', 'success')
        except SQLAlchemyError as e:
            db.session.rollback()
            logger.error(f"Error deleting post ID {id}: {e}")
            flash('An error occurred while deleting the post.', 'danger')
    else:
        logger.debug(f"CSRF validation failed for delete post ID {id}")
        flash('Invalid request.', 'danger')
    
    return redirect(url_for('blog.manage_posts'))

C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\.gitattributes:
# Auto detect text files and perform LF normalization
* text=auto


C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\.github\FUNDING.yml:
custom: ['https://buy.stripe.com/fZu14nfiYgTYelU6Cygfu0J', 'https://buy.stripe.com/cNi9AT6Ms8nsb9I7GCgfu0K', 'https://buy.stripe.com/14A3cv0o49rwb9I1iegfu0L', 'https://buy.stripe.com/3cIaEX4Ek9rw6Ts6Cygfu0M', 'https://buy.stripe.com/6oUcN51s88nsdhQ5yugfu0N', 'https://buy.stripe.com/fZu4gz6Ms1Z45Po1iegfu0O']


C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\config.py:
import os

class Config:
    WTF_CSRF_ENABLED = True
    
    # Use Heroku's DATABASE_URL if available (production), fallback to SQLite for local development
    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL', "sqlite:///mydatabase.sqlite").replace('postgres://', 'postgresql://')

    SQLALCHEMY_TRACK_MODIFICATIONS = False

C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\database.py:
from flask_sqlalchemy import SQLAlchemy

db = SQLAlchemy()


C:\Users\zimme\OneDrive\Documents\GitHub\flask-template-repo\app\routes\admin.py:
from flask import Blueprint, render_template, request, redirect, url_for, flash, current_app, make_response, jsonify
from flask_login import login_required, current_user
from app.modules.auth_manager import admin_required
from app.models import User, Estimator, Service, Appointment, ContactFormSubmission, Role, BusinessConfig
from app.forms import ManageRolesForm, EditUserForm, EstimatorForm, EstimateRequestForm, ServiceOptionForm, CSRFTokenForm, CreateUserForm, RoleForm, BusinessConfigForm
from app.database import db
from werkzeug.utils import secure_filename
import os
from datetime import datetime, date, time, timedelta
from app.modules.indexing import generate_sitemap, submit_sitemap_to_bing
from app import csrf
from datetime import datetime, timedelta, timezone, time
import pytz
from sqlalchemy.exc import IntegrityError, SQLAlchemyError

admin = Blueprint('admin', __name__, template_folder='templates')

@admin.context_processor
def combined_context_processor():
    erf_form = EstimateRequestForm()
    return dict(erf_form=erf_form, hide_estimate_form=True)

@admin.route('/dashboard')
@login_required
@admin_required
def admin_dashboard():
    total_users = User.query.count()
    contact_form_submissions = ContactFormSubmission.query.order_by(ContactFormSubmission.submitted_at.desc()).all()
    company_timezone = pytz.timezone('America/Denver')
    now_local = datetime.now(company_timezone)
    first_day = now_local.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
    if now_local.month == 12:
        next_month = now_local.replace(year=now_local.year+1, month=1, day=1, hour=0, minute=0, second=0, microsecond=0)
    else:
        next_month = now_local.replace(month=now_local.month+1, day=1, hour=0, minute=0, second=0, microsecond=0)
    first_day_utc = first_day.astimezone(pytz.utc)
    next_month_utc = next_month.astimezone(pytz.utc)
    appointments = Appointment.query.filter(
        Appointment.preferred_date_time >= first_day_utc,
        Appointment.preferred_date_time < next_month_utc
    ).order_by(Appointment.preferred_date_time.asc()).all()
    for appointment in appointments:
        if appointment.preferred_date_time:
            utc_time = appointment.preferred_date_time.replace(tzinfo=pytz.utc)
            appointment.local_time = utc_time.astimezone(company_timezone)
        else:
            appointment.local_time = None
    form = CSRFTokenForm()
    return render_template(
        'admin/dashboard.html',
        total_users=total_users,
        contact_form_submissions=contact_form_submissions,
        appointments=appointments,
        form=form
    )

@admin.route('/users')
@login_required
@admin_required
def list_users():
    users = User.query.order_by(User.username).all()
    form = CSRFTokenForm()  # Initialize the CSRF form
    return render_template('admin/list_users.html', users=users, form=form)

@admin.route('/user/new', methods=['GET', 'POST'])
@login_required
@admin_required
def new_user():
    form = CreateUserForm()
    form.roles.choices = [(role.id, role.name) for role in Role.query.all()]
    if form.validate_on_submit():
        user = User(username=form.username.data, email=form.email.data, password=form.password.data)
        user.first_name = form.first_name.data
        user.last_name = form.last_name.data
        user.phone = form.phone.data
        user.roles = [Role.query.get(id) for id in form.roles.data]
        try:
            db.session.add(user)
            db.session.commit()
            flash('User created successfully.', 'success')
            return redirect(url_for('admin.list_users'))
        except IntegrityError:
            db.session.rollback()
            flash('Username or email already in use.', 'error')
    return render_template('admin/new_user.html', form=form)

@admin.route('/user/<int:user_id>/edit', methods=['GET', 'POST'])
@login_required
@admin_required
def edit_user(user_id):
    user = User.query.get_or_404(user_id)
    form = EditUserForm(obj=user)
    form.roles.choices = [(role.id, role.name) for role in Role.query.all()]
    if request.method == 'GET':
        form.roles.data = [role.id for role in user.roles]
    if form.validate_on_submit():
        user.username = form.username.data
        user.email = form.email.data
        user.first_name = form.first_name.data
        user.last_name = form.last_name.data
        user.phone = form.phone.data
        if form.password.data:
            user.set_password(form.password.data)
        user.roles = [Role.query.get(id) for id in form.roles.data]
        try:
            db.session.commit()
            flash('User updated successfully.', 'success')
            return redirect(url_for('admin.list_users'))
        except IntegrityError:
            db.session.rollback()
            flash('Username or email already in use.', 'error')
    return render_template('admin/edit_user.html', form=form, user=user)

@admin.route('/user/<int:user_id>/delete', methods=['POST'])
@login_required
@admin_required
def delete_user(user_id):
    user = User.query.get_or_404(user_id)
    if user == current_user:
        flash('You cannot delete yourself.', 'error')
        return redirect(url_for('admin.list_users'))
    db.session.delete(user)
    db.session.commit()
    flash('User deleted successfully.', 'success')
    return redirect(url_for('admin.list_users'))

@admin.route('/roles')
@login_required
@admin_required
def list_roles():
    roles = Role.query.all()
    form = CSRFTokenForm()  # Initialize the CSRF form
    return render_template('admin/list_roles.html', roles=roles, form=form)

@admin.route('/role/new', methods=['GET', 'POST'])
@login_required
@admin_required
def new_role():
    form = RoleForm()
    if form.validate_on_submit():
        role = Role(name=form.name.data)
        try:
            db.session.add(role)
            db.session.commit()
            flash('Role created successfully.', 'success')
            return redirect(url_for('admin.list_roles'))
        except IntegrityError:
            db.session.rollback()
            flash('Role name already exists.', 'error')
    return render_template('admin/new_role.html', form=form)

@admin.route('/role/<int:role_id>/edit', methods=['GET', 'POST'])
@login_required
@admin_required
def edit_role(role_id):
    role = Role.query.get_or_404(role_id)
    form = RoleForm(obj=role)
    if form.validate_on_submit():
        role.name = form.name.data
        try:
            db.session.commit()
            flash('Role updated successfully.', 'success')
            return redirect(url_for('admin.list_roles'))
        except IntegrityError:
            db.session.rollback()
            flash('Role name already exists.', 'error')
    return render_template('admin/edit_role.html', form=form, role=role)

@admin.route('/role/<int:role_id>/delete', methods=['POST'])
@login_required
@admin_required
def delete_role(role_id):
    role = Role.query.get_or_404(role_id)
    if role.users:
        flash('Cannot delete role because it is assigned to users.', 'error')
        return redirect(url_for('admin.list_roles'))
    db.session.delete(role)
    db.session.commit()
    flash('Role deleted successfully.', 'success')
    return redirect(url_for('admin.list_roles'))

@admin.route('/estimator', methods=['GET', 'POST'])
@login_required
@admin_required
def admin_estimator():
    form = EstimatorForm()
    if form.validate_on_submit():
        estimator = Estimator(name=form.name.data)
        db.session.add(estimator)
        db.session.commit()
        return redirect(url_for('admin.admin_dashboard'))
    estimators = Estimator.query.all()
    return render_template('admin/estimator_form.html', hide_estimate_form=True, form=form, estimators=estimators)

@admin.route('/estimator/delete/<int:estimator_id>', methods=['POST'])
@login_required
@admin_required
def delete_estimator(estimator_id):
    current_app.logger.debug(f'Attempting to delete estimator with ID: {estimator_id}')
    estimator = Estimator.query.get_or_404(estimator_id)
    try:
        if estimator.appointments:
            flash('Cannot delete estimator because they are assigned to appointments.', 'error')
            return redirect(url_for('admin.admin_estimator'))
        db.session.delete(estimator)
        db.session.commit()
        current_app.logger.info(f'Estimator ID {estimator_id} deleted successfully.')
        flash('Estimator deleted successfully.', 'success')
    except SQLAlchemyError as e:
        db.session.rollback()
        current_app.logger.error(f'Error deleting estimator ID {estimator_id}: {e}')
        flash('Error deleting estimator. Please try again.', 'error')
    return redirect(url_for('admin.admin_estimator'))

@admin.route('/service', methods=['GET', 'POST'])
@login_required
@admin_required
def services():
    form = ServiceOptionForm()
    if form.validate_on_submit():
        current_app.logger.debug('Form validated successfully.')
        service = Service(
            name=form.name.data, 
            description=form.description.data, 
            display_order=form.display_order.data
        )
        current_app.logger.debug(f'Creating new Service: {service.name}')
        db.session.add(service)
        try:
            db.session.commit()
            current_app.logger.debug('New Service added to the database successfully.')
            flash('Service added successfully.', 'success')
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f'Error adding Service to the database: {e}')
            flash('Error adding Service. Please try again.', 'error')
        return redirect(url_for('admin.services'))
    else:
        if form.errors:
            current_app.logger.debug(f'Form validation errors: {form.errors}')
    services = Service.query.order_by(Service.display_order).all()
    current_app.logger.debug(f'Loaded {len(services)} Services for display.')
    return render_template('admin/service.html', hide_estimate_form=True, form=form, services=services)

@admin.route('/service/delete/<int:service_id>', methods=['POST'])
@login_required
@admin_required
def delete_service(service_id):
    current_app.logger.debug(f'Attempting to delete service with ID: {service_id}')
    service = Service.query.get_or_404(service_id)
    try:
        if service.appointments:
            flash('Cannot delete service because it is associated with appointments.', 'error')
            return redirect(url_for('admin.services'))
        db.session.delete(service)
        db.session.commit()
        current_app.logger.info(f'Service ID {service_id} deleted successfully.')
        flash('Service deleted successfully.', 'success')
    except SQLAlchemyError as e:
        db.session.rollback()
        current_app.logger.error(f'Error deleting service ID {service_id}: {e}')
        flash('Error deleting service. Please try again.', 'error')
    return redirect(url_for('admin.services'))

@admin.route('/generate-sitemap', methods=['GET'])
@login_required
@admin_required
def generate_sitemap_route():
    try:
        generate_sitemap(current_app)
        flash('Sitemap generated and saved successfully.', 'success')
        flash('Sitemap submitted to Bing successfully.', 'success')
    except Exception as e:
        flash(f'Error generating or submitting sitemap: {e}', 'error')
    return redirect(url_for('admin.admin_dashboard'))

@admin.route('/api/admin_appointments')
@csrf.exempt
@login_required
@admin_required
def admin_appointments():
    now = datetime.utcnow()
    appointments = Appointment.query.filter(
        Appointment.preferred_date_time >= now
    ).order_by(Appointment.preferred_date_time).all()
    appointments_data = [{
        'first_name': appointment.first_name,
        'last_name': appointment.last_name,
        'phone': appointment.phone,
        'email': appointment.email,
        'preferred_date_time': appointment.preferred_date_time.replace(tzinfo=pytz.utc).isoformat(),
        'service': appointment.service.name if appointment.service else 'N/A',
        'estimator': appointment.estimator.name if appointment.estimator else 'N/A',
        'start': appointment.preferred_date_time.replace(tzinfo=pytz.utc).isoformat(),
        'end': (appointment.preferred_date_time + timedelta(hours=1)).replace(tzinfo=pytz.utc).isoformat()
    } for appointment in appointments]
    return jsonify(appointments_data), 200

@admin.route('/delete_contact_submission/<int:id>', methods=['POST'])
@login_required
@admin_required
def delete_contact_submission(id):
    submission = ContactFormSubmission.query.get_or_404(id)
    db.session.delete(submission)
    db.session.commit()
    flash('Contact form submission deleted successfully.', 'success')
    return redirect(url_for('admin.admin_dashboard'))

@admin.route('/delete_appointment/<int:appointment_id>', methods=['POST'])
@login_required
@admin_required
def delete_appointment(appointment_id):
    appointment = Appointment.query.get_or_404(appointment_id)
    db.session.delete(appointment)
    db.session.commit()
    flash('Appointment deleted successfully.', 'success')
    return redirect(url_for('admin.admin_dashboard'))

@admin.route('/business_config', methods=['GET', 'POST'])
@login_required
@admin_required
def business_config():
    form = BusinessConfigForm()
    if form.validate_on_submit():
        try:
            # Update or create settings
            settings = {
                'business_start_time': form.business_start_time.data,
                'business_end_time': form.business_end_time.data,
                'buffer_time_minutes': str(form.buffer_time_minutes.data),
                'company_timezone': form.company_timezone.data
            }
            for name, value in settings.items():
                config = BusinessConfig.query.filter_by(setting_name=name).first()
                if config:
                    config.setting_value = value
                else:
                    config = BusinessConfig(setting_name=name, setting_value=value)
                    db.session.add(config)
            db.session.commit()
            current_app.logger.info('Business configuration updated successfully.')
            flash('Business settings updated successfully.', 'success')
            return redirect(url_for('admin.business_config'))
        except SQLAlchemyError as e:
            db.session.rollback()
            current_app.logger.error(f'Error updating business configuration: {e}')
            flash('Error updating settings. Please try again.', 'error')

    # Load existing settings
    configs = BusinessConfig.query.all()
    config_dict = {config.setting_name: config.setting_value for config in configs}
    if config_dict:
        form.business_start_time.data = config_dict.get('business_start_time', '08:00')
        form.business_end_time.data = config_dict.get('business_end_time', '17:00')
        form.buffer_time_minutes.data = int(config_dict.get('buffer_time_minutes', 30))
        form.company_timezone.data = config_dict.get('company_timezone', 'America/Denver')

    return render_template('admin/business_config.html', form=form, hide_estimate_form=True)

